<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/rain1017/memdb"

    >memdb-server (v0.5.7)</a>
</h1>
<h4>Distributed Transactional In-Memory Database</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server">module memdb-server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoConnect">
            function <span class="apidocSignatureSpan">memdb-server.</span>autoConnect
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection">
            function <span class="apidocSignatureSpan">memdb-server.</span>autoconnection
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker">
            function <span class="apidocSignatureSpan">memdb-server.</span>backendlocker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary">
            function <span class="apidocSignatureSpan">memdb-server.</span>binary
            <span class="apidocSignatureSpan">(buffer, subType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.client">
            function <span class="apidocSignatureSpan">memdb-server.</span>client
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection">
            function <span class="apidocSignatureSpan">memdb-server.</span>collection
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connect">
            function <span class="apidocSignatureSpan">memdb-server.</span>connect
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connectBackend">
            function <span class="apidocSignatureSpan">memdb-server.</span>connectBackend
            <span class="apidocSignatureSpan">(backend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection">
            function <span class="apidocSignatureSpan">memdb-server.</span>connection
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database">
            function <span class="apidocSignatureSpan">memdb-server.</span>database
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document">
            function <span class="apidocSignatureSpan">memdb-server.</span>document
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend">
            function <span class="apidocSignatureSpan">memdb-server.</span>mongo_backend
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid">
            function <span class="apidocSignatureSpan">memdb-server.</span>objectid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.protocol">
            function <span class="apidocSignatureSpan">memdb-server.</span>protocol
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend">
            function <span class="apidocSignatureSpan">memdb-server.</span>redis_backend
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard">
            function <span class="apidocSignatureSpan">memdb-server.</span>shard
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave">
            function <span class="apidocSignatureSpan">memdb-server.</span>slave
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>autoconnection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>backendlocker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>binary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>client.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>clientpool</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>collection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>database.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>document.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>indexbuilder</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>modifier</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>mongo_backend.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>objectid.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>protocol.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>redis_backend.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>server</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>shard.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>slave.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">memdb-server.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.autoconnection">module memdb-server.autoconnection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.autoconnection">
            function <span class="apidocSignatureSpan">memdb-server.</span>autoconnection
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.autoconnection.prototype">module memdb-server.autoconnection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype._connection">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_connection
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype._runTask">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_runTask
            <span class="apidocSignatureSpan">(shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype._runTransaction">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_runTransaction
            <span class="apidocSignatureSpan">(func, conn, shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype._shard">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_shard
            <span class="apidocSignatureSpan">(shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype._task">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_task
            <span class="apidocSignatureSpan">(method, args, shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.close">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.collection">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>collection
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.eval">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>eval
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.flushBackend">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>flushBackend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.info">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>info
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.openConnection">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>openConnection
            <span class="apidocSignatureSpan">(shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.resetCounter">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>resetCounter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.autoconnection.prototype.transaction">
            function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>transaction
            <span class="apidocSignatureSpan">(func, shardId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.backendlocker">module memdb-server.backendlocker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.backendlocker">
            function <span class="apidocSignatureSpan">memdb-server.</span>backendlocker
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.backendlocker.prototype">module memdb-server.backendlocker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype._docKey">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>_docKey
            <span class="apidocSignatureSpan">(docId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype._heartbeatKey">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>_heartbeatKey
            <span class="apidocSignatureSpan">(shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.clearHeartbeat">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>clearHeartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.getActiveShards">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>getActiveShards
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.getHolderId">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>getHolderId
            <span class="apidocSignatureSpan">(docId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.heartbeat">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>heartbeat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.isAlive">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>isAlive
            <span class="apidocSignatureSpan">(shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.isHeld">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>isHeld
            <span class="apidocSignatureSpan">(docId, shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.start">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.stop">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.tryLock">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>tryLock
            <span class="apidocSignatureSpan">(docId, shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.backendlocker.prototype.unlock">
            function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>unlock
            <span class="apidocSignatureSpan">(docId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.binary">module memdb-server.binary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.binary">
            function <span class="apidocSignatureSpan">memdb-server.</span>binary
            <span class="apidocSignatureSpan">(buffer, subType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.Binary">
            function <span class="apidocSignatureSpan">memdb-server.binary.</span>Binary
            <span class="apidocSignatureSpan">(buffer, subType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.BinaryAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.</span>BinaryAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>BUFFER_SIZE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_BYTE_ARRAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_DEFAULT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_FUNCTION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_MD5</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_USER_DEFINED</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_UUID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.binary.</span>SUBTYPE_UUID_OLD</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.binary.prototype">module memdb-server.binary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.length">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>length
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.lengthAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>lengthAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.put">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>put
            <span class="apidocSignatureSpan">(byte_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.putAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>putAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.read">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>read
            <span class="apidocSignatureSpan">(position, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.readAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>readAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.toJSON">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.toJSONAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toJSONAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.toString">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toString
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.toStringAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toStringAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.value">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>value
            <span class="apidocSignatureSpan">(asRaw)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.valueAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>valueAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.write">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>write
            <span class="apidocSignatureSpan">(string, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.binary.prototype.writeAsync">
            function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>writeAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.client">module memdb-server.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.client.client">
            function <span class="apidocSignatureSpan">memdb-server.</span>client
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.client.super_">
            function <span class="apidocSignatureSpan">memdb-server.client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.client.prototype">module memdb-server.client.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.client.prototype.connect">
            function <span class="apidocSignatureSpan">memdb-server.client.prototype.</span>connect
            <span class="apidocSignatureSpan">(host, port)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.client.prototype.disconnect">
            function <span class="apidocSignatureSpan">memdb-server.client.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.client.prototype.request">
            function <span class="apidocSignatureSpan">memdb-server.client.prototype.</span>request
            <span class="apidocSignatureSpan">(connId, method, args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.clientpool">module memdb-server.clientpool</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.clientpool.getClient">
            function <span class="apidocSignatureSpan">memdb-server.clientpool.</span>getClient
            <span class="apidocSignatureSpan">(host, port)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.collection">module memdb-server.collection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.collection">
            function <span class="apidocSignatureSpan">memdb-server.</span>collection
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.super_">
            function <span class="apidocSignatureSpan">memdb-server.collection.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.collection.prototype">module memdb-server.collection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._checkId">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_checkId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._checkName">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_checkName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._findByIndex">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_findByIndex
            <span class="apidocSignatureSpan">(indexKey, indexValue, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._finishIndexTasks">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_finishIndexTasks
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._indexCollectionName">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_indexCollectionName
            <span class="apidocSignatureSpan">(indexKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._insertById">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_insertById
            <span class="apidocSignatureSpan">(id, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._key">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_key
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._removeById">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_removeById
            <span class="apidocSignatureSpan">(id, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype._updateById">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_updateById
            <span class="apidocSignatureSpan">(id, modifier, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.close">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.commitIndex">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>commitIndex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.commitOneIndex">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>commitOneIndex
            <span class="apidocSignatureSpan">(indexKey, indexValue, changedIds, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.count">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>count
            <span class="apidocSignatureSpan">(query, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.find">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>find
            <span class="apidocSignatureSpan">(query, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.findById">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findById
            <span class="apidocSignatureSpan">(id, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.findByIdReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findByIdReadOnly
            <span class="apidocSignatureSpan">(id, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.findOne">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findOne
            <span class="apidocSignatureSpan">(query, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.findOneReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findOneReadOnly
            <span class="apidocSignatureSpan">(query, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.findReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findReadOnly
            <span class="apidocSignatureSpan">(query, fields, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.insert">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>insert
            <span class="apidocSignatureSpan">(docs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.lock">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>lock
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.onUpdateIndex">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>onUpdateIndex
            <span class="apidocSignatureSpan">(id, indexKey, oldValue, newValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.remove">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>remove
            <span class="apidocSignatureSpan">(query, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.rollbackIndex">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>rollbackIndex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.collection.prototype.update">
            function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>update
            <span class="apidocSignatureSpan">(query, modifier, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.config">module memdb-server.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.config.clusterConfig">
            function <span class="apidocSignatureSpan">memdb-server.config.</span>clusterConfig
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.config.getShardIds">
            function <span class="apidocSignatureSpan">memdb-server.config.</span>getShardIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.config.init">
            function <span class="apidocSignatureSpan">memdb-server.config.</span>init
            <span class="apidocSignatureSpan">(confPath, shardId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.config.shardConfig">
            function <span class="apidocSignatureSpan">memdb-server.config.</span>shardConfig
            <span class="apidocSignatureSpan">(shardId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.connection">module memdb-server.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.connection">
            function <span class="apidocSignatureSpan">memdb-server.</span>connection
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.connection.prototype">module memdb-server.connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.close">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>close
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.commit">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>commit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.count">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>count
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.find">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>find
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.findById">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findById
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.findByIdReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findByIdReadOnly
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.findOne">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findOne
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.findOneReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findOneReadOnly
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.findReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findReadOnly
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.flushBackend">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>flushBackend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.getCollection">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>getCollection
            <span class="apidocSignatureSpan">(name, isIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.insert">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>insert
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.isDirty">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>isDirty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.lock">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>lock
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.remove">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.rollback">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>rollback
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.connection.prototype.update">
            function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>update
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.database">module memdb-server.database</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.database">
            function <span class="apidocSignatureSpan">memdb-server.</span>database
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.super_">
            function <span class="apidocSignatureSpan">memdb-server.database.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.database.prototype">module memdb-server.database.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.prototype.connect">
            function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>connect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.prototype.disconnect">
            function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>disconnect
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.prototype.execute">
            function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>execute
            <span class="apidocSignatureSpan">(connId, method, args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.prototype.getConnection">
            function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>getConnection
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.prototype.start">
            function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.database.prototype.stop">
            function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>stop
            <span class="apidocSignatureSpan">(force)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.document">module memdb-server.document</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.document">
            function <span class="apidocSignatureSpan">memdb-server.</span>document
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.super_">
            function <span class="apidocSignatureSpan">memdb-server.document.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.document.prototype">module memdb-server.document.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype._getChanged">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_getChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype._getCommited">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_getCommited
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype._getIndexValue">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_getIndexValue
            <span class="apidocSignatureSpan">(indexKey, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype._unlock">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_unlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype._waitUnlock">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_waitUnlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.commit">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>commit
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.ensureLocked">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>ensureLocked
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.exists">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>exists
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.find">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>find
            <span class="apidocSignatureSpan">(connId, fields)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.insert">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>insert
            <span class="apidocSignatureSpan">(connId, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.isFree">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>isFree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.isLocked">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>isLocked
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.lock">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>lock
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.modify">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>modify
            <span class="apidocSignatureSpan">(connId, cmd, param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.remove">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>remove
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.rollback">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>rollback
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.document.prototype.update">
            function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>update
            <span class="apidocSignatureSpan">(connId, modifier, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.indexbuilder">module memdb-server.indexbuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.indexbuilder.drop">
            function <span class="apidocSignatureSpan">memdb-server.indexbuilder.</span>drop
            <span class="apidocSignatureSpan">(conf, collName, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.indexbuilder.rebuild">
            function <span class="apidocSignatureSpan">memdb-server.indexbuilder.</span>rebuild
            <span class="apidocSignatureSpan">(conf, collName, keys, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.modifier">module memdb-server.modifier</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.mongo_backend">module memdb-server.mongo_backend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.mongo_backend">
            function <span class="apidocSignatureSpan">memdb-server.</span>mongo_backend
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.mongo_backend.prototype">module memdb-server.mongo_backend.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.drop">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>drop
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.ensureConnected">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>ensureConnected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.get">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>get
            <span class="apidocSignatureSpan">(name, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.getAll">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>getAll
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.getCollectionNames">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>getCollectionNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.set">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>set
            <span class="apidocSignatureSpan">(name, id, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.setMulti">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>setMulti
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.start">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.mongo_backend.prototype.stop">
            function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.objectid">module memdb-server.objectid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.objectid">
            function <span class="apidocSignatureSpan">memdb-server.</span>objectid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.ObjectID">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectID
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.ObjectIDAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectIDAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.ObjectId">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectId
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.ObjectIdAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectIdAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.createFromHexString">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromHexString
            <span class="apidocSignatureSpan">(hexString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.createFromHexStringAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromHexStringAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.createFromTime">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromTime
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.createFromTimeAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromTimeAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.createPk">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createPk
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.createPkAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createPkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.isValid">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>isValid
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.isValidAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.</span>isValidAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">memdb-server.objectid.</span>index</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.objectid.prototype">module memdb-server.objectid.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.equals">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>equals
            <span class="apidocSignatureSpan">(otherID)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.equalsAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>equalsAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.generate">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>generate
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.generateAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>generateAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.getInc">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getInc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.getIncAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getIncAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.getTimestamp">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getTimestamp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.getTimestampAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getTimestampAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.get_inc">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>get_inc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.get_incAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>get_incAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.inspect">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>inspect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.inspectAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>inspectAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.toHexString">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toHexString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.toHexStringAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toHexStringAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.toJSON">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.toJSONAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toJSONAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.toString">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.objectid.prototype.toStringAsync">
            function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toStringAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.protocol">module memdb-server.protocol</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.protocol.protocol">
            function <span class="apidocSignatureSpan">memdb-server.</span>protocol
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.protocol.super_">
            function <span class="apidocSignatureSpan">memdb-server.protocol.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.protocol.prototype">module memdb-server.protocol.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.protocol.prototype.disconnect">
            function <span class="apidocSignatureSpan">memdb-server.protocol.prototype.</span>disconnect
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.protocol.prototype.send">
            function <span class="apidocSignatureSpan">memdb-server.protocol.prototype.</span>send
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.redis_backend">module memdb-server.redis_backend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.redis_backend">
            function <span class="apidocSignatureSpan">memdb-server.</span>redis_backend
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.redis_backend.prototype">module memdb-server.redis_backend.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.drop">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>drop
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.get">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>get
            <span class="apidocSignatureSpan">(name, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.getAll">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>getAll
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.getCollectionNames">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>getCollectionNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.set">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>set
            <span class="apidocSignatureSpan">(name, id, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.setMulti">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>setMulti
            <span class="apidocSignatureSpan">(items)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.start">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.redis_backend.prototype.stop">
            function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.server">module memdb-server.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.server.start">
            function <span class="apidocSignatureSpan">memdb-server.server.</span>start
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.shard">module memdb-server.shard</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.shard">
            function <span class="apidocSignatureSpan">memdb-server.</span>shard
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.super_">
            function <span class="apidocSignatureSpan">memdb-server.shard.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.shard.prototype">module memdb-server.shard.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._addDoc">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_addDoc
            <span class="apidocSignatureSpan">(key, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._cancelIdleTimeout">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_cancelIdleTimeout
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._doc">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_doc
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._ensureState">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_ensureState
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._isLoaded">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_isLoaded
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._load">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_load
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._lockBackend">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_lockBackend
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._persistent">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_persistent
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._resolveKey">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_resolveKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._setCommited">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_setCommited
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._startIdleTimeout">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_startIdleTimeout
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._unload">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_unload
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype._unlockBackend">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_unlockBackend
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.commit">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>commit
            <span class="apidocSignatureSpan">(connId, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.find">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>find
            <span class="apidocSignatureSpan">(connId, key, fields)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.findReadOnly">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>findReadOnly
            <span class="apidocSignatureSpan">(connId, key, fields)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.flushBackend">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>flushBackend
            <span class="apidocSignatureSpan">(connId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.gc">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>gc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.insert">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>insert
            <span class="apidocSignatureSpan">(connId, key, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.isLocked">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>isLocked
            <span class="apidocSignatureSpan">(connId, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.lock">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>lock
            <span class="apidocSignatureSpan">(connId, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.remove">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>remove
            <span class="apidocSignatureSpan">(connId, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.restoreFromSlave">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>restoreFromSlave
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.rollback">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>rollback
            <span class="apidocSignatureSpan">(connId, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.start">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.stop">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.shard.prototype.update">
            function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>update
            <span class="apidocSignatureSpan">(connId, key, doc, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.slave">module memdb-server.slave</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.slave">
            function <span class="apidocSignatureSpan">memdb-server.</span>slave
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.slave.prototype">module memdb-server.slave.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype._extractKey">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>_extractKey
            <span class="apidocSignatureSpan">(existKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype._redisKey">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>_redisKey
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.clear">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.del">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>del
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.getAllKeys">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>getAllKeys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.getMulti">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>getMulti
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.set">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>set
            <span class="apidocSignatureSpan">(key, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.setMulti">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>setMulti
            <span class="apidocSignatureSpan">(docs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.start">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>start
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.slave.prototype.stop">
            function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>stop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.memdb-server.utils">module memdb-server.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.clone">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.deleteObjPath">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>deleteObjPath
            <span class="apidocSignatureSpan">(obj, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.escapeField">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>escapeField
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.extendPromise">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>extendPromise
            <span class="apidocSignatureSpan">(P)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.forceHashMap">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>forceHashMap
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.getObjPath">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>getObjPath
            <span class="apidocSignatureSpan">(obj, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.hrtimer">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>hrtimer
            <span class="apidocSignatureSpan">(autoStart)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.isDict">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>isDict
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.isEmpty">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>isEmpty
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.mongoForEach">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>mongoForEach
            <span class="apidocSignatureSpan">(itor, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.rateCounter">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>rateCounter
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.remoteExec">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>remoteExec
            <span class="apidocSignatureSpan">(ip, cmd, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.setObjPath">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>setObjPath
            <span class="apidocSignatureSpan">(obj, path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.timeCounter">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>timeCounter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.unescapeField">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>unescapeField
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.uuid">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>uuid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.memdb-server.utils.waitUntil">
            function <span class="apidocSignatureSpan">memdb-server.utils.</span>waitUntil
            <span class="apidocSignatureSpan">(fn, checkInterval)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server" id="apidoc.module.memdb-server">module memdb-server</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.autoConnect" id="apidoc.element.memdb-server.autoConnect">
        function <span class="apidocSignatureSpan">memdb-server.</span>autoConnect
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoConnect = function (opts){
    var conn = new AutoConnection(opts);
    return P.resolve(conn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

mongoose.connect = function(opts){
    var promise = P.bind(this)
    .then(function(){
if(this._autoconn){
    throw new Error(&#x27;Already connected&#x27;);
}
return memdb.<span class="apidocCodeKeywordSpan">autoConnect</span>(opts);
    })
    .then(function(ret){
this._autoconn = ret;

if(opts &#x26;&#x26; opts.backend){
    return P.promisify(connectMongo, mongoose)(opts.backend.url);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection" id="apidoc.element.memdb-server.autoconnection">
        function <span class="apidocSignatureSpan">memdb-server.</span>autoconnection
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoconnection = function (opts){
    opts = opts || {};

    this.db = opts.db;

    this.config = {
        maxConnection : opts.maxConnection || DEFAULT_MAX_CONNECTION,
        connectionIdleTimeout : opts.connectionIdleTimeout || DEFAULT_CONNECTION_IDLE_TIMEOUT,
        maxPendingTask : opts.maxPendingTask || DEFAULT_MAX_PENDING_TASK,
        reconnectInterval : opts.reconnectInterval || DEFAULT_RECONNECT_INTERVAL,

        // allow concurrent request inside one connection, internal use only
        concurrentInConnection : opts.concurrentInConnection || false,

        // {shardId : {host : &#x27;127.0.0.1&#x27;, port : 31017}}
        shards : opts.shards || {},
    };

    if(this.config.concurrentInConnection){
        this.config.maxConnection = 1;
    }

    var shardIds = Object.keys(this.config.shards);
    if(shardIds.length === 0){
        throw new Error(&#x27;please specify opts.shards&#x27;);
    }

    var shards = {};
    shardIds.forEach(function(shardId){
        shards[shardId] = {
            connections : {}, // {connId : connection}
            freeConnections : {}, // {connId : true}
            connectionTimeouts : {}, // {connId : timeout}
            pendingTasks : [],
            reconnectInterval : null,
        };
    });
    this.shards = shards;

    this.openConnectionLock = new AsyncLock({Promise : P, maxPending : 10000});
    this.collections = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker" id="apidoc.element.memdb-server.backendlocker">
        function <span class="apidocSignatureSpan">memdb-server.</span>backendlocker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backendlocker = function (opts){
    opts = opts || {};

    this.shardId = opts.shardId;
    this.config = {
        host : opts.host || &#x27;127.0.0.1&#x27;,
        port : opts.port || 6379,
        db : opts.db || 0,
        options : opts.options || {},
        prefix : opts.prefix || &#x27;bl$&#x27;,
        heartbeatPrefix  : opts.heartbeatPrefix || &#x27;hb$&#x27;,
        heartbeatTimeout : opts.heartbeatTimeout,
        heartbeatInterval : opts.heartbeatInterval,
    };

    this.client = null;
    this.heartbeatInterval = null;

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary" id="apidoc.element.memdb-server.binary">
        function <span class="apidocSignatureSpan">memdb-server.</span>binary
        <span class="apidocSignatureSpan">(buffer, subType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = &#x27;Binary&#x27;;

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null &#x26;&#x26; !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == &#x27;string&#x27;) {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != &#x27;undefined&#x27;) {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != &#x27;undefined&#x27; || (Object.prototype.toString.call(buffer) == &#x27;[object Array]&#x27;)) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error(&#x22;only String, Buffer, Uint8Array or Array accepted&#x22;);
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != &#x27;undefined&#x27;) {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    } else if(typeof Uint8Array != &#x27;undefined&#x27;){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.client" id="apidoc.element.memdb-server.client">
        function <span class="apidocSignatureSpan">memdb-server.</span>client
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">client = function (){
    EventEmitter.call(this);

    this.protocol = null;
    this.seq = 1;
    this.requests = {}; //{seq : deferred}
    this.domains = {}; //{seq : domain} saved domains

    this.disconnectDeferred = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection" id="apidoc.element.memdb-server.collection">
        function <span class="apidocSignatureSpan">memdb-server.</span>collection
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collection = function (opts){
    opts = opts || {};

    this.name = opts.name;
    this._checkName(this.name);

    this.shard = opts.shard;
    this.conn = opts.conn;
    this.config = opts.config || {};
    this.config.maxCollision = this.config.maxCollision || DEFAULT_MAX_COLLISION;

    // {indexKey : {indexValue : {id1 : 1, id2 : -1}}}
    this.changedIndexes = utils.forceHashMap();

    this.pendingIndexTasks = utils.forceHashMap(); //{id, [Promise]}

    this.updateIndexEvent = &#x27;updateIndex$&#x27; + this.name + &#x27;$&#x27; + this.conn._id;
    this.shard.on(this.updateIndexEvent, this.onUpdateIndex.bind(this));

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);

    EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var main = P.coroutine(function*(){
// Connect to memdb
var autoconn = yield memdb.autoConnect({
    shards : {s1 : {host : &#x27;127.0.0.1&#x27;, port : 31017}}
});

var Player = autoconn.<span class="apidocCodeKeywordSpan">collection</span>(&#x27;player&#x27;);

// make transaction in shard s1
yield autoconn.transaction(P.coroutine(function*(){
    // Insert players
    var players = [{_id : &#x27;p1&#x27;, name : &#x27;rain&#x27;, areaId : 1},
                   {_id : &#x27;p2&#x27;, name : &#x27;snow&#x27;, areaId : 2}];
    yield Player.insert(players);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connect" id="apidoc.element.memdb-server.connect">
        function <span class="apidocSignatureSpan">memdb-server.</span>connect
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (opts){
    var conn = new Connection(opts);
    return P.try(function(){
        return conn.connect();
    })
    .thenReturn(conn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            P.try(function(){
if(msg.method === &#x27;connect&#x27;){
    var clientVersion = msg.args[0];
    if(parseFloat(clientVersion) &#x3c; parseFloat(consts.minClientVersion)){
        throw new Error(&#x27;client version not supported, please upgrade&#x27;);
    }
    var connId = db.<span class="apidocCodeKeywordSpan">connect</span>().connId;
    connIds[connId] = true;
    return {
        connId : connId,
    };
}
if(!msg.connId){
    throw new Error(&#x27;connId is required&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connectBackend" id="apidoc.element.memdb-server.connectBackend">
        function <span class="apidocSignatureSpan">memdb-server.</span>connectBackend
        <span class="apidocSignatureSpan">(backend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connectBackend = function (backend){
    var mongodb = P.promisifyAll(require(&#x27;mongodb&#x27;));
    return P.promisify(mongodb.MongoClient.connect)(backend.url, backend.options)
    .then(function(db){
        var getCollection = db.collection;
        db.collection = function(){
            var coll = getCollection.apply(db, arguments);
            var disabledMethods = [&#x27;createIndex&#x27;, &#x27;drop&#x27;, &#x27;dropIndex&#x27;, &#x27;dropIndexes&#x27;, &#x27;ensureIndex&#x27;,
            &#x27;findAndModify&#x27;, &#x27;getCollection&#x27;, &#x27;getDB&#x27;, &#x27;insert&#x27;, &#x27;remove&#x27;, &#x27;renameCollection&#x27;, &#x27;save&#x27;, &#x27;update&#x27;];
            disabledMethods.forEach(function(method){
                coll[method] = function(){
                    throw new Error(&#x27;write to backend is forbidden&#x27;);
                };
            });
            return coll;
        };
        return db;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection" id="apidoc.element.memdb-server.connection">
        function <span class="apidocSignatureSpan">memdb-server.</span>connection
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connection = function (opts){
    opts = opts || {};

    this._id = opts._id;
    this.shard = opts.shard;

    this.config = opts.config || {};
    this.collections = {};

    this.lockedKeys = utils.forceHashMap();

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database" id="apidoc.element.memdb-server.database">
        function <span class="apidocSignatureSpan">memdb-server.</span>database
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">database = function (opts){
    // clone since we want to modify it
    opts = utils.clone(opts) || {};

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);

    this.connections = utils.forceHashMap();
    this.connectionLock = new AsyncLock({Promise : P});

    this.dbWrappers = utils.forceHashMap(); //{connId : dbWrapper}

    this.opsCounter = utils.rateCounter();
    this.tpsCounter = utils.rateCounter();

    opts.slowQuery = opts.slowQuery || DEFAULT_SLOWQUERY;

    // Parse index config
    opts.collections = opts.collections || {};

    Object.keys(opts.collections).forEach(function(name){
        var collection = opts.collections[name];
        var indexes = {};
        (collection.indexes || []).forEach(function(index){
            if(!Array.isArray(index.keys)){
                index.keys = [index.keys];
            }
            var indexKey = JSON.stringify(index.keys.sort());
            if(indexes[indexKey]){
                throw new Error(&#x27;Duplicate index keys - &#x27; + indexKey);
            }

            delete index.keys;
            indexes[indexKey] = index;
        });
        collection.indexes = indexes;
    });

    this.logger.info(&#x27;parsed opts: %j&#x27;, opts);

    this.shard = new Shard(opts);

    this.config = opts;

    this.timeCounter = utils.timeCounter();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document" id="apidoc.element.memdb-server.document">
        function <span class="apidocSignatureSpan">memdb-server.</span>document
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">document = function (opts){ //jshint ignore:line
    opts = opts || {};

    if(!opts.hasOwnProperty(&#x27;_id&#x27;)){
        throw new Error(&#x27;_id is not specified&#x27;);
    }
    this._id = opts._id;

    var doc = opts.doc || null;
    if(typeof(doc) !== &#x27;object&#x27;){
        throw new Error(&#x27;doc must be object&#x27;);
    }
    if(!!doc){
        doc._id = this._id;
    }

    this.commited = doc;
    this.changed = undefined; // undefined means no change, while null means removed
    this.connId = null; // Connection that hold the document lock

    this.locker = opts.locker;
    this.lockKey = opts.lockKey;
    if(!this.locker){
        this.locker = new AsyncLock({
                            Promise : P,
                            timeout : opts.lockTimeout || DEFAULT_LOCK_TIMEOUT
                            });
        this.lockKey = &#x27;&#x27;;
    }

    this.releaseCallback = null;

    this.indexes = opts.indexes || {};

    this.savedIndexValues = {}; //{indexKey : indexValue}

    EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend" id="apidoc.element.memdb-server.mongo_backend">
        function <span class="apidocSignatureSpan">memdb-server.</span>mongo_backend
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mongo_backend = function (opts){
    opts = opts || {};

    this.config = {
        url : opts.url || &#x27;mongodb://localhost/test&#x27;,
        options : {server : {socketOptions : {autoReconnect : true}, reconnectTries : 10000000, reconnectInterval : 5000}}, //always
 retry
    };
    this.conn = null;
    this.connected = false;
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid" id="apidoc.element.memdb-server.objectid">
        function <span class="apidocSignatureSpan">memdb-server.</span>objectid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  if(!(this instanceof ObjectID)) return new ObjectID(id);
  // Duck-typing to support ObjectId from different npm packages
  if((id instanceof ObjectID) || (id &#x26;&#x26; id.toHexString)) return id;

  this._bsontype = &#x27;ObjectID&#x27;;
  var __id = null;
  var valid = ObjectID.isValid(id);

  // Throw an error if it&#x27;s not a valid setup
  if(!valid &#x26;&#x26; id != null){
    throw new Error(&#x22;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x22;);
  } else if(valid &#x26;&#x26; typeof id == &#x27;string&#x27; &#x26;&#x26; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id == null || typeof id == &#x27;number&#x27;) {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null &#x26;&#x26; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.protocol" id="apidoc.element.memdb-server.protocol">
        function <span class="apidocSignatureSpan">memdb-server.</span>protocol
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">protocol = function (opts){
    EventEmitter.call(this);

    opts = opts || {};

    this.socket = opts.socket;
    this.socket.setEncoding(&#x27;utf8&#x27;);

    this.maxMsgLength = opts.maxMsgLength || DEFAULT_MAX_MSG_LENGTH;

    this.remainLine = &#x27;&#x27;;

    var self = this;
    this.socket.on(&#x27;data&#x27;, function(data){
        // message is json encoded and splited by &#x27;\n&#x27;
        var lines = data.split(&#x27;\n&#x27;);
        for(var i=0; i&#x3c;lines.length - 1; i++){
            try{
                var msg = &#x27;&#x27;;
                if(i === 0){
                    msg = JSON.parse(self.remainLine + lines[i]);
                    self.remainLine = &#x27;&#x27;;
                }
                else{
                    msg = JSON.parse(lines[i]);
                }
                self.emit(&#x27;msg&#x27;, msg);
            }
            catch(err){
                logger.error(err.stack);
            }
        }
        self.remainLine = lines[lines.length - 1];
    });

    this.socket.on(&#x27;close&#x27;, function(hadError){
        self.emit(&#x27;close&#x27;, hadError);
    });

    this.socket.on(&#x27;connect&#x27;, function(){
        self.emit(&#x27;connect&#x27;);
    });

    this.socket.on(&#x27;error&#x27;, function(err){
        self.emit(&#x27;error&#x27;, err);
    });

    this.socket.on(&#x27;timeout&#x27;, function(){
        self.emit(&#x27;timeout&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend" id="apidoc.element.memdb-server.redis_backend">
        function <span class="apidocSignatureSpan">memdb-server.</span>redis_backend
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redis_backend = function (opts){
    opts = opts || {};

    this.config = {
        host : opts.host || &#x27;127.0.0.1&#x27;,
        port : opts.port || 6379,
        db : opts.db || 0,
        options : opts.option || {},
        prefix : opts.prefix || &#x27;&#x27;,
    };
    this.conn = null;

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard" id="apidoc.element.memdb-server.shard">
        function <span class="apidocSignatureSpan">memdb-server.</span>shard
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shard = function (opts){
    EventEmitter.call(this);

    opts = opts || {};

    this._id = opts.shardId;
    if(!this._id){
        throw new Error(&#x27;shardId is empty&#x27;);
    }
    this._id = this._id.toString();
    if(this._id.indexOf(&#x27;$&#x27;) !== -1){
        throw new Error(&#x27;shardId can not contain &#x22;$&#x22;&#x27;);
    }

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this._id);

    this.config = {
        locking : opts.locking || {},
        backend : opts.backend || {},
        slave : opts.slave || {},

        shards : opts.shards || {},

        idleTimeout : opts.hasOwnProperty(&#x27;idleTimeout&#x27;) ? opts.idleTimeout : DEFAULT_IDLE_TIMEOUT,
        persistentDelay : opts.hasOwnProperty(&#x27;persistentDelay&#x27;) ?  opts.persistentDelay : DEFAULT_PERSISTENT_DELAY,

        heartbeatInterval : opts.heartbeatInterval || DEFAULT_HEARTBEAT_INTERVAL,
        heartbeatTimeout : opts.heartbeatTimeout || DEFAULT_HEARTBEAT_TIMEOUT,
        backendLockTimeout : opts.backendLockTimeout || DEFAULT_BACKEND_LOCK_TIMEOUT,
        backendLockRetryInterval : opts.backendLockRetryInterval || DEFAULT_BACKEND_LOCK_RETRY_INTERVAL,
        reloadDelay : opts.reloadDelay || DEFAULT_RELOAD_DELAY,
        lockTimeout : opts.lockTimeout || DEFAULT_LOCK_TIMEOUT,

        memoryLimit : opts.memoryLimit || DEFAULT_MEMORY_LIMIT,
        gcCount : opts.gcCount || DEFAULT_GC_COUNT,
        gcInterval : opts.gcInterval || DEFAULT_GC_INTERVAL,

        disableSlave : opts.disableSlave || false,

        collections : opts.collections || {},
    };

    // global locking
    var lockerConf = this.config.locking;
    lockerConf.shardId = this._id;
    lockerConf.heartbeatTimeout = this.config.heartbeatTimeout;
    lockerConf.heartbeatInterval = this.config.heartbeatInterval;
    this.backendLocker = new BackendLocker(lockerConf);

    // backend storage
    var backendConf = this.config.backend;
    backendConf.shardId = this._id;
    this.backend = backends.create(backendConf);

    // slave redis
    var slaveConf = this.config.slave;
    slaveConf.shardId = this._id;
    this.slave = new Slave(slaveConf);

    // memdb client to communicate with other shards
    this.autoconn = new AutoConnection({
        shards : this.config.shards,
        concurrentInConnection : true,
    });

    // Document storage {key : doc}
    this.docs = utils.forceHashMap();

    // Newly commited docs (for incremental _save)
    this.commitedKeys = utils.forceHashMap(); // {key : version}

    // Idle timeout before unload
    this.idleTimeouts = utils.forceHashMap(); // {key : timeout}

    // Doc persistent timeout
    this.persistentTimeouts = utils.forceHashMap(); // {key : timeout}

    // GC interval
    this.gcInterval = null;

    // Lock async operations for each key
    this.keyLock = new AsyncLock({Promise : P});

    // Task locker
    this.taskLock = new AsyncLock({Promise : P});

    // Doc locker
    this.docLock = new AsyncLock({
        timeout : this.config.lockTimeout,
        Promise : P,
    });

    // Current concurrent commiting processes
    this.commitingCount = 0;

    // Current key unloading task
    this.unloadingKeys = utils.forceHashMap();

    this.loadCounter = utils.rateCounter();
    this.unloadCounter = utils.rateCounter();
    this.persistentCounter = utils.rateCounter();

    this.state = STATE.INITED;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave" id="apidoc.element.memdb-server.slave">
        function <span class="apidocSignatureSpan">memdb-server.</span>slave
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slave = function (opts){
    opts = opts || {};

    this.shardId = opts.shardId;

    this.config = {
        host : opts.host || &#x27;127.0.0.1&#x27;,
        port : opts.port || 6379,
        db : opts.db || 0,
        options : opts.options || {},
    };

    this.client = null;
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.autoconnection" id="apidoc.module.memdb-server.autoconnection">module memdb-server.autoconnection</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.autoconnection" id="apidoc.element.memdb-server.autoconnection.autoconnection">
        function <span class="apidocSignatureSpan">memdb-server.</span>autoconnection
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoconnection = function (opts){
    opts = opts || {};

    this.db = opts.db;

    this.config = {
        maxConnection : opts.maxConnection || DEFAULT_MAX_CONNECTION,
        connectionIdleTimeout : opts.connectionIdleTimeout || DEFAULT_CONNECTION_IDLE_TIMEOUT,
        maxPendingTask : opts.maxPendingTask || DEFAULT_MAX_PENDING_TASK,
        reconnectInterval : opts.reconnectInterval || DEFAULT_RECONNECT_INTERVAL,

        // allow concurrent request inside one connection, internal use only
        concurrentInConnection : opts.concurrentInConnection || false,

        // {shardId : {host : &#x27;127.0.0.1&#x27;, port : 31017}}
        shards : opts.shards || {},
    };

    if(this.config.concurrentInConnection){
        this.config.maxConnection = 1;
    }

    var shardIds = Object.keys(this.config.shards);
    if(shardIds.length === 0){
        throw new Error(&#x27;please specify opts.shards&#x27;);
    }

    var shards = {};
    shardIds.forEach(function(shardId){
        shards[shardId] = {
            connections : {}, // {connId : connection}
            freeConnections : {}, // {connId : true}
            connectionTimeouts : {}, // {connId : timeout}
            pendingTasks : [],
            reconnectInterval : null,
        };
    });
    this.shards = shards;

    this.openConnectionLock = new AsyncLock({Promise : P, maxPending : 10000});
    this.collections = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.autoconnection.prototype" id="apidoc.module.memdb-server.autoconnection.prototype">module memdb-server.autoconnection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype._connection" id="apidoc.element.memdb-server.autoconnection.prototype._connection">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_connection
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_connection = function (){
    var info = process.domain &#x26;&#x26; process.domain.__memdb__;
    if(!info){
        throw new Error(&#x27;You are not in any transaction scope&#x27;);
    }
    var shard = this._shard(info.shard);
    var conn = shard.connections[info.conn];
    if(!conn){
        throw new Error(&#x27;connection &#x27; + info.conn + &#x27; not exist&#x27;);
    }
    return conn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.collection = function(name){
var self = this;
if(!this.collections[name]){
    var collection = {};
    // Method must be called inside transaction
    consts.collMethods.forEach(function(method){
        collection[method] = function(){
            var conn = self.<span class="apidocCodeKeywordSpan">_connection</span>();
            var args = [name].concat([].slice.call(arguments));
            return conn[method].apply(conn, args);
        };
    });

    this.collections[name] = collection;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype._runTask" id="apidoc.element.memdb-server.autoconnection.prototype._runTask">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_runTask
        <span class="apidocSignatureSpan">(shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runTask = function (shardId){
    var self = this;
    var shard = this._shard(shardId);

    if(shard.pendingTasks.length === 0){
        return;
    }

    var connIds = Object.keys(shard.freeConnections);
    if(connIds.length === 0){
        return this.openConnection(shardId);
    }

    var connId = connIds[0];
    var conn = shard.connections[connId];
    if(!this.config.concurrentInConnection){
        delete shard.freeConnections[connId];
    }

    var task = shard.pendingTasks.shift();

    if(this.config.concurrentInConnection){
        // start run next before current task finish
        setImmediate(function(){
            self._runTask(shardId);
        });
    }

    return P.try(function(){
        if(task.method === &#x27;__t&#x27;){
            var func = task.args[0];
            return self._runTransaction(func, conn, shardId);
        }
        else{
            var method = conn[task.method];
            if(typeof(method) !== &#x27;function&#x27;){
                throw new Error(&#x27;invalid method - &#x27; + task.method);
            }
            return method.apply(conn, task.args);
        }
    })
    .then(function(ret){
        task.deferred.resolve(ret);
    }, function(err){
        task.deferred.reject(err);
    })
    .finally(function(){
        if(shard.connections.hasOwnProperty(connId)){
            shard.freeConnections[connId] = true;
        }

        setImmediate(function(){
            self._runTask(shardId);
        });
    })
    .catch(function(e){
        logger.error(e.stack);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    conn.on(&#x27;close&#x27;, function(){
        logger.info(&#x27;[shard:%s][conn:%s] connection closed&#x27;, shardId, connId);
        delete shard.connections[connId];
        delete shard.freeConnections[connId];
    });

    setImmediate(function(){
        return self.<span class="apidocCodeKeywordSpan">_runTask</span>(shardId);
    });
}, function(e){
    if(!shard.reconnectInterval){
        shard.reconnectInterval = setInterval(function(){
            return self.openConnection(shardId);
        }, self.config.reconnectInterval);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype._runTransaction" id="apidoc.element.memdb-server.autoconnection.prototype._runTransaction">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_runTransaction
        <span class="apidocSignatureSpan">(func, conn, shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_runTransaction = function (func, conn, shardId){
    if(typeof(func) !== &#x27;function&#x27;){
        throw new Error(&#x27;Function is required&#x27;);
    }

    var deferred = P.defer();

    var scope = domain.create();
    scope.__memdb__ = {shard: shardId, conn: conn._connId, trans : uuid.v4()};

    var self = this;
    scope.run(function(){
        logger.info(&#x27;[shard:%s][conn:%s] transaction start&#x27;, shardId, conn._connId);

        var startTick = Date.now();

        return P.try(function(){
            return func();
        })
        .then(function(ret){
            return conn.commit()
            .then(function(){
                logger.info(&#x27;[shard:%s][conn:%s] transaction done (%sms)&#x27;, shardId, conn._connId, Date.now() - startTick);
                delete scope.__memdb__;
                deferred.resolve(ret);
            });
        }, function(err){
            return conn.rollback()
            .then(function(){
                logger.error(&#x27;[shard:%s][conn:%s] transaction error %s&#x27;, shardId, conn._connId, err.stack);
                delete scope.__memdb__;
                deferred.reject(err);
            });
        })
        .catch(function(e){
            logger.error(e.stack);
            deferred.reject(e);
        });
    });

    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        self._runTask(shardId);
    });
}

return P.try(function(){
    if(task.method === &#x27;__t&#x27;){
        var func = task.args[0];
        return self.<span class="apidocCodeKeywordSpan">_runTransaction</span>(func, conn, shardId);
    }
    else{
        var method = conn[task.method];
        if(typeof(method) !== &#x27;function&#x27;){
            throw new Error(&#x27;invalid method - &#x27; + task.method);
        }
        return method.apply(conn, task.args);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype._shard" id="apidoc.element.memdb-server.autoconnection.prototype._shard">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_shard
        <span class="apidocSignatureSpan">(shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_shard = function (shardId){
    var shard = this.shards[shardId];
    if(!shard){
        throw new Error(&#x27;shard &#x27; + shardId + &#x27; not exist&#x27;);
    }
    return shard;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

proto.openConnection = function(shardId){
    var self = this;

    return this.openConnectionLock.acquire(shardId, function(){
var shard = self.<span class="apidocCodeKeywordSpan">_shard</span>(shardId);
if(Object.keys(shard.connections).length &#x3e;= self.config.maxConnection){
    return;
}

var conn = new Connection({
                        host : self.config.shards[shardId].host,
                        port : self.config.shards[shardId].port,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype._task" id="apidoc.element.memdb-server.autoconnection.prototype._task">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>_task
        <span class="apidocSignatureSpan">(method, args, shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_task = function (method, args, shardId){
    var deferred = P.defer();
    try{
        if(!shardId){
            var shardIds = Object.keys(this.shards);
            if(shardIds.length &#x3e; 1){
                throw new Error(&#x27;You must specify shardId&#x27;);
            }
            shardId = shardIds[0];
        }

        var shard = this._shard(shardId);

        if(shard.pendingTasks.length &#x3e;= this.config.maxPendingTask){
            throw new Error(&#x27;Too much pending tasks&#x27;);
        }

        shard.pendingTasks.push({
            method : method,
            args : args,
            deferred : deferred
        });

        var self = this;
        setImmediate(function(){
            return self._runTask(shardId);
        });
    }
    catch(err){
        deferred.reject(err);
    }
    finally{
        return deferred.promise;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(method === &#x27;commit&#x27; || method === &#x27;rollback&#x27;){
        return;
    }
    // Methods not bind to transaction
    proto[method] = function(){
        var shardId = arguments[0];
        var args = [].slice.call(arguments, 1);
        return this.<span class="apidocCodeKeywordSpan">_task</span>(method, args, shardId);
    };
});

proto.transaction = function(func, shardId){
    return this._task(&#x27;__t&#x27;, [func], shardId);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.close" id="apidoc.element.memdb-server.autoconnection.prototype.close">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (){
    var self = this;
    // Close all connections to all shards
    return P.map(Object.keys(this.shards), function(shardId){
        var shard = self.shards[shardId];

        clearInterval(shard.reconnectInterval);
        shard.reconnectInterval = null;

        // reject all pending tasks
        shard.pendingTasks.forEach(function(task){
            task.deferred.reject(new Error(&#x27;connection closed&#x27;));
        });
        shard.pendingTasks = [];

        // close all connections
        var connections = shard.connections;
        return P.map(Object.keys(connections), function(connId){
            var conn = connections[connId];
            if(conn){
                return conn.close();
            }
        });
    })
    .then(function(){
        logger.info(&#x27;autoConnection closed&#x27;);
    })
    .catch(function(err){
        logger.error(err.stack);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var proto = Connection.prototype;

proto.close = function(){
if(this.isDirty()){
    this.rollback();
}
for(var name in this.collections){
    this.collections[name].<span class="apidocCodeKeywordSpan">close</span>();
}
};

consts.collMethods.forEach(function(method){
proto[method] = function(name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.collection" id="apidoc.element.memdb-server.autoconnection.prototype.collection">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>collection
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collection = function (name){
    var self = this;
    if(!this.collections[name]){
        var collection = {};
        // Method must be called inside transaction
        consts.collMethods.forEach(function(method){
            collection[method] = function(){
                var conn = self._connection();
                var args = [name].concat([].slice.call(arguments));
                return conn[method].apply(conn, args);
            };
        });

        this.collections[name] = collection;
    }
    return this.collections[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var main = P.coroutine(function*(){
// Connect to memdb
var autoconn = yield memdb.autoConnect({
    shards : {s1 : {host : &#x27;127.0.0.1&#x27;, port : 31017}}
});

var Player = autoconn.<span class="apidocCodeKeywordSpan">collection</span>(&#x27;player&#x27;);

// make transaction in shard s1
yield autoconn.transaction(P.coroutine(function*(){
    // Insert players
    var players = [{_id : &#x27;p1&#x27;, name : &#x27;rain&#x27;, areaId : 1},
                   {_id : &#x27;p2&#x27;, name : &#x27;snow&#x27;, areaId : 2}];
    yield Player.insert(players);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.eval" id="apidoc.element.memdb-server.autoconnection.prototype.eval">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>eval
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (){
    var shardId = arguments[0];
    var args = [].slice.call(arguments, 1);
    return this._task(method, args, shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.flushBackend" id="apidoc.element.memdb-server.autoconnection.prototype.flushBackend">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>flushBackend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushBackend = function (){
    var shardId = arguments[0];
    var args = [].slice.call(arguments, 1);
    return this._task(method, args, shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.lockedKeys = {};

    this.logger.debug(&#x27;[conn:%s] rolledback&#x27;, this._id);
    return true;
};

proto.flushBackend = function(){
    return this.shard.<span class="apidocCodeKeywordSpan">flushBackend</span>(this._id);
};

// for internal use
proto.$unload = function(key){
    return this.shard.$unload(key);
};
// for internal use
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.info" id="apidoc.element.memdb-server.autoconnection.prototype.info">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>info
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">info = function (){
    var shardId = arguments[0];
    var args = [].slice.call(arguments, 1);
    return this._task(method, args, shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function(){
    if(this.shardId &#x26;&#x26; this.config.heartbeatInterval &#x3e; 0){
        this.heartbeatInterval = setInterval(this.heartbeat.bind(this), this.config.heartbeatInterval);
        return this.heartbeat();
    }
})
.then(function(){
    this.logger.<span class="apidocCodeKeywordSpan">info</span>(&#x27;backendLocker started %s:%s:%s&#x27;, this.config.host, this
.config.port, this.config.db);
});
};

proto.stop = function(){
return P.bind(this)
.then(function(){
    clearInterval(this.heartbeatInterval);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.openConnection" id="apidoc.element.memdb-server.autoconnection.prototype.openConnection">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>openConnection
        <span class="apidocSignatureSpan">(shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openConnection = function (shardId){
    var self = this;

    return this.openConnectionLock.acquire(shardId, function(){
        var shard = self._shard(shardId);
        if(Object.keys(shard.connections).length &#x3e;= self.config.maxConnection){
            return;
        }

        var conn = new Connection({
                                host : self.config.shards[shardId].host,
                                port : self.config.shards[shardId].port,
                                idleTimeout : self.config.connectionIdleTimeout
                            });

        return conn.connect()
        .then(function(connId){
            clearInterval(shard.reconnectInterval);
            shard.reconnectInterval = null;

            shard.connections[connId] = conn;

            logger.info(&#x27;[shard:%s][conn:%s] open connection&#x27;, shardId, connId);

            shard.freeConnections[connId] = true;

            conn.on(&#x27;close&#x27;, function(){
                logger.info(&#x27;[shard:%s][conn:%s] connection closed&#x27;, shardId, connId);
                delete shard.connections[connId];
                delete shard.freeConnections[connId];
            });

            setImmediate(function(){
                return self._runTask(shardId);
            });
        }, function(e){
            if(!shard.reconnectInterval){
                shard.reconnectInterval = setInterval(function(){
                    return self.openConnection(shardId);
                }, self.config.reconnectInterval);
            }
            logger.error(e.stack);

            if(Object.keys(shard.connections).length === 0){
                logger.error(&#x27;No connection available for shard %s&#x27;, shardId);

                // no available connection, reject all pending tasks
                shard.pendingTasks.forEach(function(task){
                    task.deferred.reject(e);
                });
                shard.pendingTasks = [];
            }
        });
    })
    .catch(function(e){
        logger.error(e.stack);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

setImmediate(function(){
    return self._runTask(shardId);
});
        }, function(e){
if(!shard.reconnectInterval){
    shard.reconnectInterval = setInterval(function(){
        return self.<span class="apidocCodeKeywordSpan">openConnection</span>(shardId);
    }, self.config.reconnectInterval);
}
logger.error(e.stack);

if(Object.keys(shard.connections).length === 0){
    logger.error(&#x27;No connection available for shard %s&#x27;, shardId);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.resetCounter" id="apidoc.element.memdb-server.autoconnection.prototype.resetCounter">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>resetCounter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetCounter = function (){
    var shardId = arguments[0];
    var args = [].slice.call(arguments, 1);
    return this._task(method, args, shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.autoconnection.prototype.transaction" id="apidoc.element.memdb-server.autoconnection.prototype.transaction">
        function <span class="apidocSignatureSpan">memdb-server.autoconnection.prototype.</span>transaction
        <span class="apidocSignatureSpan">(func, shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transaction = function (func, shardId){
    return this._task(&#x27;__t&#x27;, [func], shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new Error(&#x27;Please connect first&#x27;);
    }
    return mongoose._autoconn;
}
});

mongoose.transaction = function(func, shardId, cb){
var promise = this.autoconn.<span class="apidocCodeKeywordSpan">transaction</span>(func, shardId);

if(typeof(cb) === &#x27;function&#x27;){
    return promise.nodeify(cb);
}
else{
    return promise;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.backendlocker" id="apidoc.module.memdb-server.backendlocker">module memdb-server.backendlocker</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.backendlocker" id="apidoc.element.memdb-server.backendlocker.backendlocker">
        function <span class="apidocSignatureSpan">memdb-server.</span>backendlocker
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backendlocker = function (opts){
    opts = opts || {};

    this.shardId = opts.shardId;
    this.config = {
        host : opts.host || &#x27;127.0.0.1&#x27;,
        port : opts.port || 6379,
        db : opts.db || 0,
        options : opts.options || {},
        prefix : opts.prefix || &#x27;bl$&#x27;,
        heartbeatPrefix  : opts.heartbeatPrefix || &#x27;hb$&#x27;,
        heartbeatTimeout : opts.heartbeatTimeout,
        heartbeatInterval : opts.heartbeatInterval,
    };

    this.client = null;
    this.heartbeatInterval = null;

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.backendlocker.prototype" id="apidoc.module.memdb-server.backendlocker.prototype">module memdb-server.backendlocker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype._docKey" id="apidoc.element.memdb-server.backendlocker.prototype._docKey">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>_docKey
        <span class="apidocSignatureSpan">(docId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_docKey = function (docId){
    return this.config.prefix + docId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

proto.tryLock = function(docId, shardId){
this.logger.debug(&#x27;tryLock %s&#x27;, docId);

var self = this;
return this.client.setnxAsync(this.<span class="apidocCodeKeywordSpan">_docKey</span>(docId), shardId || this.shardId)
.then(function(ret){
    if(ret === 1){
        self.logger.debug(&#x27;locked %s&#x27;, docId);
        return true;
    }
    else{
        return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype._heartbeatKey" id="apidoc.element.memdb-server.backendlocker.prototype._heartbeatKey">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>_heartbeatKey
        <span class="apidocSignatureSpan">(shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_heartbeatKey = function (shardId){
    return this.config.heartbeatPrefix + shardId;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.heartbeat = function(){
    var timeout = Math.floor(this.config.heartbeatTimeout / 1000);
    if(timeout &#x3c;= 0){
        timeout = 1;
    }

    var self = this;
    return this.client.setexAsync(this.<span class="apidocCodeKeywordSpan">_heartbeatKey</span>(this.shardId), timeout, 1)
    .then(function(){
        self.logger.debug(&#x27;heartbeat&#x27;);
    })
    .catch(function(err){
        self.logger.error(err.stack);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.clearHeartbeat" id="apidoc.element.memdb-server.backendlocker.prototype.clearHeartbeat">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>clearHeartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearHeartbeat = function (){
    return this.client.delAsync(this._heartbeatKey(this.shardId));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

proto.stop = function(){
return P.bind(this)
.then(function(){
    clearInterval(this.heartbeatInterval);
    return this.<span class="apidocCodeKeywordSpan">clearHeartbeat</span>();
})
.then(function(){
    return this.client.quitAsync();
})
.then(function(){
    this.logger.info(&#x27;backendLocker stoped&#x27;);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.getActiveShards" id="apidoc.element.memdb-server.backendlocker.prototype.getActiveShards">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>getActiveShards
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getActiveShards = function (){
    var prefix = this.config.heartbeatPrefix;
    return this.client.keysAsync(prefix + &#x27;*&#x27;)
    .then(function(keys){
        return keys.map(function(key){
            return key.slice(prefix.length);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lockingConf.heartbeatInterval = 0;
var backendLocker = new BackendLocker(lockingConf);

return P.try(function(){
    return backendLocker.start();
})
.then(function(){
    return backendLocker.<span class="apidocCodeKeywordSpan">getActiveShards</span>();
})
.then(function(shardIds){
    if(shardIds.length &#x3e; 0){
        throw new Error(&#x27;You should shutdown all shards first&#x27;);
    }
})
.finally(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.getHolderId" id="apidoc.element.memdb-server.backendlocker.prototype.getHolderId">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>getHolderId
        <span class="apidocSignatureSpan">(docId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getHolderId = function (docId){
    return this.client.getAsync(this._docKey(docId));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

proto.getHolderId = function(docId){
    return this.client.getAsync(this._docKey(docId));
};

proto.isHeld = function(docId, shardId){
    var self = this;
    return this.<span class="apidocCodeKeywordSpan">getHolderId</span>(docId)
    .then(function(ret){
        return ret === (shardId || self.shardId);
    });
};

// concurrency safe between shards
// not concurrency safe in same shard
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.heartbeat" id="apidoc.element.memdb-server.backendlocker.prototype.heartbeat">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>heartbeat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heartbeat = function (){
    var timeout = Math.floor(this.config.heartbeatTimeout / 1000);
    if(timeout &#x3c;= 0){
        timeout = 1;
    }

    var self = this;
    return this.client.setexAsync(this._heartbeatKey(this.shardId), timeout, 1)
    .then(function(){
        self.logger.debug(&#x27;heartbeat&#x27;);
    })
    .catch(function(err){
        self.logger.error(err.stack);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                }
            });
        }
    })
    .then(function(){
        if(this.shardId &#x26;&#x26; this.config.heartbeatInterval &#x3e; 0){
            this.heartbeatInterval = setInterval(this.heartbeat.bind(this), this.config.heartbeatInterval);
            return this.<span class="apidocCodeKeywordSpan">heartbeat</span>();
        }
    })
    .then(function(){
        this.logger.info(&#x27;backendLocker started %s:%s:%s&#x27;, this.config.host, this.config.port, this.config.db);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.isAlive" id="apidoc.element.memdb-server.backendlocker.prototype.isAlive">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>isAlive
        <span class="apidocSignatureSpan">(shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAlive = function (shardId){
    return this.client.existsAsync(this._heartbeatKey(shardId || this.shardId))
    .then(function(ret){
        return !!ret;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.client.on(&#x27;error&#x27;, function(err){
        self.logger.error(err.stack);
    });
    return this.client.selectAsync(this.config.db);
})
.then(function(){
    if(this.shardId){
        return this.<span class="apidocCodeKeywordSpan">isAlive</span>()
        .then(function(ret){
            if(ret){
                throw new Error(&#x27;Current shard is running in some other process&#x27;);
            }
        });
    }
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.isHeld" id="apidoc.element.memdb-server.backendlocker.prototype.isHeld">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>isHeld
        <span class="apidocSignatureSpan">(docId, shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHeld = function (docId, shardId){
    var self = this;
    return this.getHolderId(docId)
    .then(function(ret){
        return ret === (shardId || self.shardId);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// concurrency safe between shards
// not concurrency safe in same shard
proto.unlock = function(docId){
    this.logger.debug(&#x27;unlock %s&#x27;, docId);

    var self = this;
    return this.<span class="apidocCodeKeywordSpan">isHeld</span>(docId)
    .then(function(held){
        if(held){
            return self.client.delAsync(self._docKey(docId));
        }
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.start" id="apidoc.element.memdb-server.backendlocker.prototype.start">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (){
    return P.bind(this)
    .then(function(){
        this.client = redis.createClient(this.config.port, this.config.host, {retry_max_delay : 10 * 1000, enable_offline_queue :
true});
        var self = this;
        this.client.on(&#x27;error&#x27;, function(err){
            self.logger.error(err.stack);
        });
        return this.client.selectAsync(this.config.db);
    })
    .then(function(){
        if(this.shardId){
            return this.isAlive()
            .then(function(ret){
                if(ret){
                    throw new Error(&#x27;Current shard is running in some other process&#x27;);
                }
            });
        }
    })
    .then(function(){
        if(this.shardId &#x26;&#x26; this.config.heartbeatInterval &#x3e; 0){
            this.heartbeatInterval = setInterval(this.heartbeat.bind(this), this.config.heartbeatInterval);
            return this.heartbeat();
        }
    })
    .then(function(){
        this.logger.info(&#x27;backendLocker started %s:%s:%s&#x27;, this.config.host, this.config.port, this.config.db);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.stop" id="apidoc.element.memdb-server.backendlocker.prototype.stop">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (){
    return P.bind(this)
    .then(function(){
        clearInterval(this.heartbeatInterval);
        return this.clearHeartbeat();
    })
    .then(function(){
        return this.client.quitAsync();
    })
    .then(function(){
        this.logger.info(&#x27;backendLocker stoped&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.logger.info(&#x27;database started&#x27;);
    });
};

proto.stop = function(force){
    var self = this;

    this.opsCounter.<span class="apidocCodeKeywordSpan">stop</span>();
    this.tpsCounter.stop();

    return P.try(function(){
// Make sure no new request come anymore

// Wait for all operations finish
return utils.waitUntil(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.tryLock" id="apidoc.element.memdb-server.backendlocker.prototype.tryLock">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>tryLock
        <span class="apidocSignatureSpan">(docId, shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryLock = function (docId, shardId){
    this.logger.debug(&#x27;tryLock %s&#x27;, docId);

    var self = this;
    return this.client.setnxAsync(this._docKey(docId), shardId || this.shardId)
    .then(function(ret){
        if(ret === 1){
            self.logger.debug(&#x27;locked %s&#x27;, docId);
            return true;
        }
        else{
            return false;
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });
};

// internal method, not concurrency safe
proto._lockBackend = function(key){
    var self = this;
    return P.try(function(){
return self.backendLocker.<span class="apidocCodeKeywordSpan">tryLock</span>(key);
    })
    .then(function(success){
if(success){
    return;
}

var startTick = Date.now();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.backendlocker.prototype.unlock" id="apidoc.element.memdb-server.backendlocker.prototype.unlock">
        function <span class="apidocSignatureSpan">memdb-server.backendlocker.prototype.</span>unlock
        <span class="apidocSignatureSpan">(docId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlock = function (docId){
    this.logger.debug(&#x27;unlock %s&#x27;, docId);

    var self = this;
    return this.isHeld(docId)
    .then(function(held){
        if(held){
            return self.client.delAsync(self._docKey(docId));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    };

    return tryLock(self.config.backendLockRetryInterval);
});
};

proto._unlockBackend = function(key){
return this.backendLocker.<span class="apidocCodeKeywordSpan">unlock</span>(key);
};

// internal method, not concurrency safe
proto._persistent = function(key){
if(!this.commitedKeys.hasOwnProperty(key)){
    return; // no change
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.binary" id="apidoc.module.memdb-server.binary">module memdb-server.binary</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.binary.binary" id="apidoc.element.memdb-server.binary.binary">
        function <span class="apidocSignatureSpan">memdb-server.</span>binary
        <span class="apidocSignatureSpan">(buffer, subType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = &#x27;Binary&#x27;;

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null &#x26;&#x26; !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == &#x27;string&#x27;) {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != &#x27;undefined&#x27;) {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != &#x27;undefined&#x27; || (Object.prototype.toString.call(buffer) == &#x27;[object Array]&#x27;)) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error(&#x22;only String, Buffer, Uint8Array or Array accepted&#x22;);
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != &#x27;undefined&#x27;) {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    } else if(typeof Uint8Array != &#x27;undefined&#x27;){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.Binary" id="apidoc.element.memdb-server.binary.Binary">
        function <span class="apidocSignatureSpan">memdb-server.binary.</span>Binary
        <span class="apidocSignatureSpan">(buffer, subType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);

  this._bsontype = &#x27;Binary&#x27;;

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null &#x26;&#x26; !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == &#x27;string&#x27;) {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != &#x27;undefined&#x27;) {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != &#x27;undefined&#x27; || (Object.prototype.toString.call(buffer) == &#x27;[object Array]&#x27;)) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error(&#x22;only String, Buffer, Uint8Array or Array accepted&#x22;);
      }
    } else {
      this.buffer = buffer;
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != &#x27;undefined&#x27;) {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);
    } else if(typeof Uint8Array != &#x27;undefined&#x27;){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.BinaryAsync" id="apidoc.element.memdb-server.binary.BinaryAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.</span>BinaryAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BinaryAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;Binary&#x27;] : fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.binary.prototype" id="apidoc.module.memdb-server.binary.prototype">module memdb-server.binary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.length" id="apidoc.element.memdb-server.binary.prototype.length">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>length
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function length() {
  return this.position;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.lengthAsync" id="apidoc.element.memdb-server.binary.prototype.lengthAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>lengthAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lengthAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;length&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.put" id="apidoc.element.memdb-server.binary.prototype.put">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>put
        <span class="apidocSignatureSpan">(byte_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function put(byte_value) {
  // If it&#x27;s a string and a has more than one character throw an error
  if(byte_value[&#x27;length&#x27;] != null &#x26;&#x26; typeof byte_value != &#x27;number&#x27; &#x26;&#x26; byte_value.length != 1) throw new Error(&#x22;only accepts single
 character String, Uint8Array or Array&#x22;);
  if(typeof byte_value != &#x27;number&#x27; &#x26;&#x26; byte_value &#x3c; 0 || byte_value &#x3e; 255) throw new Error(&#x22;only accepts number in a valid unsigned
 byte range 0-255&#x22;);

  // Decode the byte value once
  var decoded_byte = null;
  if(typeof byte_value == &#x27;string&#x27;) {
    decoded_byte = byte_value.charCodeAt(0);
  } else if(byte_value[&#x27;length&#x27;] != null) {
    decoded_byte = byte_value[0];
  } else {
    decoded_byte = byte_value;
  }

  if(this.buffer.length &#x3e; this.position) {
    this.buffer[this.position++] = decoded_byte;
  } else {
    if(typeof Buffer != &#x27;undefined&#x27; &#x26;&#x26; Buffer.isBuffer(this.buffer)) {
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    } else {
      var buffer = null;
      // Create a new buffer (typed or normal array)
      if(Object.prototype.toString.call(this.buffer) == &#x27;[object Uint8Array]&#x27;) {
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
      } else {
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
      }

      // We need to copy all the content to the new array
      for(var i = 0; i &#x3c; this.buffer.length; i++) {
        buffer[i] = this.buffer[i];
      }

      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.putAsync" id="apidoc.element.memdb-server.binary.prototype.putAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>putAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">putAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;put&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.read" id="apidoc.element.memdb-server.binary.prototype.read">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>read
        <span class="apidocSignatureSpan">(position, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(position, length) {
  length = length &#x26;&#x26; length &#x3e; 0
    ? length
    : this.position;

  // Let&#x27;s return the data based on the type we have
  if(this.buffer[&#x27;slice&#x27;]) {
    return this.buffer.slice(position, position + length);
  } else {
    // Create a buffer to keep the result
    var buffer = typeof Uint8Array != &#x27;undefined&#x27; ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
    for(var i = 0; i &#x3c; length; i++) {
      buffer[i] = this.buffer[position++];
    }
  }
  // Return the buffer
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.readAsync" id="apidoc.element.memdb-server.binary.prototype.readAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>readAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;read&#x27;] : fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.toJSON" id="apidoc.element.memdb-server.binary.prototype.toJSON">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.buffer != null ? this.buffer.toString(&#x27;base64&#x27;) : &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.toJSONAsync" id="apidoc.element.memdb-server.binary.prototype.toJSONAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toJSONAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSONAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;toJSON&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.toString" id="apidoc.element.memdb-server.binary.prototype.toString">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toString
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function (format) {
  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._checkId = function(id){
if(typeof(id) === &#x27;string&#x27;){
    return id;
}
else if(typeof(id) === &#x27;number&#x27;){
    return id.<span class="apidocCodeKeywordSpan">toString</span>();
}
throw new Error(&#x27;id must be number or string&#x27;);
};

//http://docs.mongodb.org/manual/reference/limits/#Restriction-on-Collection-Names
proto._checkName = function(name){
if(!name){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.toStringAsync" id="apidoc.element.memdb-server.binary.prototype.toStringAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>toStringAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toStringAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;toString&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.value" id="apidoc.element.memdb-server.binary.prototype.value">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>value
        <span class="apidocSignatureSpan">(asRaw)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function value(asRaw) {
  asRaw = asRaw == null ? false : asRaw;

  // Optimize to serialize for the situation where the data == size of buffer
  if(asRaw &#x26;&#x26; typeof Buffer != &#x27;undefined&#x27; &#x26;&#x26; Buffer.isBuffer(this.buffer) &#x26;&#x26; this.buffer.length == this.position)
    return this.buffer;

  // If it&#x27;s a node.js buffer object
  if(typeof Buffer != &#x27;undefined&#x27; &#x26;&#x26; Buffer.isBuffer(this.buffer)) {
    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString(&#x27;binary&#x27;, 0, this.position);
  } else {
    if(asRaw) {
      // we support the slice command use it
      if(this.buffer[&#x27;slice&#x27;] != null) {
        return this.buffer.slice(0, this.position);
      } else {
        // Create a new buffer to copy content to
        var newBuffer = Object.prototype.toString.call(this.buffer) == &#x27;[object Uint8Array]&#x27; ? new Uint8Array(new ArrayBuffer(this
.position)) : new Array(this.position);
        // Copy content
        for(var i = 0; i &#x3c; this.position; i++) {
          newBuffer[i] = this.buffer[i];
        }
        // Return the buffer
        return newBuffer;
      }
    } else {
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.valueAsync" id="apidoc.element.memdb-server.binary.prototype.valueAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>valueAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;value&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.write" id="apidoc.element.memdb-server.binary.prototype.write">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>write
        <span class="apidocSignatureSpan">(string, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(string, offset) {
  offset = typeof offset == &#x27;number&#x27; ? offset : this.position;

  // If the buffer is to small let&#x27;s extend the buffer
  if(this.buffer.length &#x3c; offset + string.length) {
    var buffer = null;
    // If we are in node.js
    if(typeof Buffer != &#x27;undefined&#x27; &#x26;&#x26; Buffer.isBuffer(this.buffer)) {
      buffer = new Buffer(this.buffer.length + string.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
    } else if(Object.prototype.toString.call(this.buffer) == &#x27;[object Uint8Array]&#x27;) {
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
      // Copy the content
      for(var i = 0; i &#x3c; this.position; i++) {
        buffer[i] = this.buffer[i];
      }
    }

    // Assign the new buffer
    this.buffer = buffer;
  }

  if(typeof Buffer != &#x27;undefined&#x27; &#x26;&#x26; Buffer.isBuffer(string) &#x26;&#x26; Buffer.isBuffer(this.buffer)) {
    string.copy(this.buffer, offset, 0, string.length);
    this.position = (offset + string.length) &#x3e; this.position ? (offset + string.length) : this.position;
    // offset = string.length
  } else if(typeof Buffer != &#x27;undefined&#x27; &#x26;&#x26; typeof string == &#x27;string&#x27; &#x26;&#x26; Buffer.isBuffer(this.buffer)) {
    this.buffer.write(string, offset, &#x27;binary&#x27;);
    this.position = (offset + string.length) &#x3e; this.position ? (offset + string.length) : this.position;
    // offset = string.length;
  } else if(Object.prototype.toString.call(string) == &#x27;[object Uint8Array]&#x27;
    || Object.prototype.toString.call(string) == &#x27;[object Array]&#x27; &#x26;&#x26; typeof string != &#x27;string&#x27;) {
    for(var i = 0; i &#x3c; string.length; i++) {
      this.buffer[offset++] = string[i];
    }

    this.position = offset &#x3e; this.position ? offset : this.position;
  } else if(typeof string == &#x27;string&#x27;) {
    for(var i = 0; i &#x3c; string.length; i++) {
      this.buffer[offset++] = string.charCodeAt(i);
    }

    this.position = offset &#x3e; this.position ? offset : this.position;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Protocol.prototype.send = function(msg){
var data = JSON.stringify(msg) + &#x27;\n&#x27;;
if(data.length &#x3e; this.maxMsgLength){
    throw new Error(&#x27;msg length exceed limit&#x27;);
}

var ret = this.socket.<span class="apidocCodeKeywordSpan">write</span>(data);
if(!ret){
    logger.warn(&#x27;socket.write return false&#x27;);
}
};

Protocol.prototype.disconnect = function(){
this.socket.end();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.binary.prototype.writeAsync" id="apidoc.element.memdb-server.binary.prototype.writeAsync">
        function <span class="apidocSignatureSpan">memdb-server.binary.prototype.</span>writeAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;write&#x27;] : fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.client" id="apidoc.module.memdb-server.client">module memdb-server.client</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.client.client" id="apidoc.element.memdb-server.client.client">
        function <span class="apidocSignatureSpan">memdb-server.</span>client
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">client = function (){
    EventEmitter.call(this);

    this.protocol = null;
    this.seq = 1;
    this.requests = {}; //{seq : deferred}
    this.domains = {}; //{seq : domain} saved domains

    this.disconnectDeferred = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.client.super_" id="apidoc.element.memdb-server.client.super_">
        function <span class="apidocSignatureSpan">memdb-server.client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.client.prototype" id="apidoc.module.memdb-server.client.prototype">module memdb-server.client.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.client.prototype.connect" id="apidoc.element.memdb-server.client.prototype.connect">
        function <span class="apidocSignatureSpan">memdb-server.client.prototype.</span>connect
        <span class="apidocSignatureSpan">(host, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (host, port){
    if(!!this.protocol){
        throw new Error(&#x27;connect already called&#x27;);
    }

    var self = this;
    logger.debug(&#x27;start connect to %s:%s&#x27;, host, port);

    var connectDeferred = P.defer();

    var socket = net.createConnection(port, host);

    this.protocol = new Protocol({socket : socket});

    this.protocol.once(&#x27;connect&#x27;, function(){
        logger.info(&#x27;connected to %s:%s&#x27;, host, port);
        connectDeferred.resolve();
    });

    this.protocol.on(&#x27;close&#x27;, function(){
        logger.info(&#x27;disconnected from %s:%s&#x27;, host, port);

        // reject all remaining requests
        for(var seq in self.requests){
            process.domain = self.domains[seq];
            self.requests[seq].reject(new Error(&#x27;connection closed&#x27;));
        }
        self.requests = {};
        self.domains = {};

        // Server will not disconnect if the client process exit immediately
        // So delay resolve promise
        if(self.disconnectDeferred){
            setTimeout(function(){
                self.disconnectDeferred.resolve();
            }, 1);
        }
        self.protocol = null;

        self.emit(&#x27;close&#x27;);
    });

    this.protocol.on(&#x27;msg&#x27;, function(msg){
        var request = self.requests[msg.seq];
        if(!request){
            return;
        }

        // restore saved domain
        process.domain = self.domains[msg.seq];

        if(!msg.err){
            logger.info(&#x27;%s:%s =&#x3e; %j&#x27;, host, port, msg);
            request.resolve(msg.data);
        }
        else{
            logger.error(&#x27;%s:%s =&#x3e; %j&#x27;, host, port, msg);
            request.reject(msg.err);
        }
        delete self.requests[msg.seq];
        delete self.domains[msg.seq];
    });

    this.protocol.on(&#x27;error&#x27;, function(err){
        if(!connectDeferred.isResolved()){
            connectDeferred.reject(err);
        }
        // Reject all pending requests
        Object.keys(self.requests).forEach(function(seq){
            // restore saved domain
            process.domain = self.domains[seq];
            self.requests[seq].reject(err);

            delete self.domains[seq];
            delete self.requests[seq];
        });
    });

    this.protocol.on(&#x27;timeout&#x27;, function(){
        self.disconnect();
    });

    return connectDeferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            P.try(function(){
if(msg.method === &#x27;connect&#x27;){
    var clientVersion = msg.args[0];
    if(parseFloat(clientVersion) &#x3c; parseFloat(consts.minClientVersion)){
        throw new Error(&#x27;client version not supported, please upgrade&#x27;);
    }
    var connId = db.<span class="apidocCodeKeywordSpan">connect</span>().connId;
    connIds[connId] = true;
    return {
        connId : connId,
    };
}
if(!msg.connId){
    throw new Error(&#x27;connId is required&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.client.prototype.disconnect" id="apidoc.element.memdb-server.client.prototype.disconnect">
        function <span class="apidocSignatureSpan">memdb-server.client.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (){
    if(!this.protocol){
        return;
    }

    this.disconnectDeferred = P.defer();
    this.protocol.disconnect();

    return this.disconnectDeferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            connId : connId,
        };
    }
    if(!msg.connId){
        throw new Error(&#x27;connId is required&#x27;);
    }
    if(msg.method === &#x27;disconnect&#x27;){
        return db.<span class="apidocCodeKeywordSpan">disconnect</span>(msg.connId)
        .then(function(){
            delete connIds[msg.connId];
        });
    }
    return db.execute(msg.connId, msg.method, msg.args);
})
.then(function(ret){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.client.prototype.request" id="apidoc.element.memdb-server.client.prototype.request">
        function <span class="apidocSignatureSpan">memdb-server.client.prototype.</span>request
        <span class="apidocSignatureSpan">(connId, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (connId, method, args){
    if(!this.protocol){
        throw new Error(&#x27;not connected&#x27;);
    }

    var seq = this.seq++;

    var deferred = P.defer();
    this.requests[seq] = deferred;

    var msg = {
        seq : seq,
        connId : connId,
        method : method,
        args : args,
    };

    this.protocol.send(msg);

    // save domain
    this.domains[seq] = process.domain;

    logger.info(&#x27;%s:%s &#x3c;= %j&#x27;, this.protocol.socket.remoteAddress, this.protocol.socket.remotePort, msg);

    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.clientpool" id="apidoc.module.memdb-server.clientpool">module memdb-server.clientpool</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.clientpool.getClient" id="apidoc.element.memdb-server.clientpool.getClient">
        function <span class="apidocSignatureSpan">memdb-server.clientpool.</span>getClient
        <span class="apidocSignatureSpan">(host, port)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getClient = function (host, port){
    var key = host + &#x27;:&#x27; + port;

    return connectLock.acquire(key, function(){
        if(clients[key]){
            return clients[key];
        }

        var client = new Client();
        client.setMaxListeners(1025);

        return P.try(function(){
            return client.connect(host, port);
        })
        .then(function(){
            clients[key] = client;

            client.on(&#x27;close&#x27;, function(){
                delete clients[key];
            });
            return client;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.collection" id="apidoc.module.memdb-server.collection">module memdb-server.collection</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.collection.collection" id="apidoc.element.memdb-server.collection.collection">
        function <span class="apidocSignatureSpan">memdb-server.</span>collection
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collection = function (opts){
    opts = opts || {};

    this.name = opts.name;
    this._checkName(this.name);

    this.shard = opts.shard;
    this.conn = opts.conn;
    this.config = opts.config || {};
    this.config.maxCollision = this.config.maxCollision || DEFAULT_MAX_COLLISION;

    // {indexKey : {indexValue : {id1 : 1, id2 : -1}}}
    this.changedIndexes = utils.forceHashMap();

    this.pendingIndexTasks = utils.forceHashMap(); //{id, [Promise]}

    this.updateIndexEvent = &#x27;updateIndex$&#x27; + this.name + &#x27;$&#x27; + this.conn._id;
    this.shard.on(this.updateIndexEvent, this.onUpdateIndex.bind(this));

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);

    EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var main = P.coroutine(function*(){
// Connect to memdb
var autoconn = yield memdb.autoConnect({
    shards : {s1 : {host : &#x27;127.0.0.1&#x27;, port : 31017}}
});

var Player = autoconn.<span class="apidocCodeKeywordSpan">collection</span>(&#x27;player&#x27;);

// make transaction in shard s1
yield autoconn.transaction(P.coroutine(function*(){
    // Insert players
    var players = [{_id : &#x27;p1&#x27;, name : &#x27;rain&#x27;, areaId : 1},
                   {_id : &#x27;p2&#x27;, name : &#x27;snow&#x27;, areaId : 2}];
    yield Player.insert(players);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.super_" id="apidoc.element.memdb-server.collection.super_">
        function <span class="apidocSignatureSpan">memdb-server.collection.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.collection.prototype" id="apidoc.module.memdb-server.collection.prototype">module memdb-server.collection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._checkId" id="apidoc.element.memdb-server.collection.prototype._checkId">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_checkId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkId = function (id){
    if(typeof(id) === &#x27;string&#x27;){
        return id;
    }
    else if(typeof(id) === &#x27;number&#x27;){
        return id.toString();
    }
    throw new Error(&#x27;id must be number or string&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!utils.isDict(doc)){
    throw new Error(&#x27;doc must be a dictionary&#x27;);
}

if(id === null || id === undefined){
    id = utils.uuid();
}
id = this.<span class="apidocCodeKeywordSpan">_checkId</span>(id);
doc._id = id;

var self = this;
return P.try(function(){
    return self.lock(id);
})
.then(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._checkName" id="apidoc.element.memdb-server.collection.prototype._checkName">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_checkName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkName = function (name){
    if(!name){
        throw new Error(&#x27;Collection name can not empty&#x27;);
    }
    if(typeof(name) !== &#x27;string&#x27;){
        throw new Error(&#x27;Collection name must be string&#x27;);
    }
    if(name.indexOf(&#x27;$&#x27;) !== -1){
        throw new Error(&#x27;Collection name can not contain &#x22;$&#x22;&#x27;);
    }
    if(name.indexOf(&#x27;system.&#x27;) === 0){
        throw new Error(&#x27;Collection name can not begin with &#x22;system.&#x22;&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var DEFAULT_MAX_COLLISION = 10000;

var Collection = function(opts){
opts = opts || {};

this.name = opts.name;
this.<span class="apidocCodeKeywordSpan">_checkName</span>(this.name);

this.shard = opts.shard;
this.conn = opts.conn;
this.config = opts.config || {};
this.config.maxCollision = this.config.maxCollision || DEFAULT_MAX_COLLISION;

// {indexKey : {indexValue : {id1 : 1, id2 : -1}}}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._findByIndex" id="apidoc.element.memdb-server.collection.prototype._findByIndex">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_findByIndex
        <span class="apidocSignatureSpan">(indexKey, indexValue, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findByIndex = function (indexKey, indexValue, fields, opts){
    opts = opts || {};
    var self = this;

    var indexCollection = this.conn.getCollection(this._indexCollectionName(indexKey), true);

    var nolock = opts.nolock;

    return P.try(function(){
        opts.nolock = true; // force not using lock
        return indexCollection.findById(indexValue, &#x27;format ids&#x27;, opts);
    })
    .then(function(doc){
        opts.nolock = nolock; // restore param

        var ids = utils.forceHashMap();

        if(doc){
            doc.ids.forEach(function(id){
                ids[id] = 1;
            });
        }

        var changedIds = (self.changedIndexes[indexKey] &#x26;&#x26; self.changedIndexes[indexKey][indexValue]) || {};
        for(var id in changedIds){
            if(changedIds[id] === 1){
                ids[id] = 1;
            }
            else{
                delete ids[id];
            }
        }

        ids = Object.keys(ids);
        if(opts &#x26;&#x26; opts.count){ // return count only
            return ids.length;
        }
        if(opts &#x26;&#x26; opts.limit){
            ids = ids.slice(0, opts.limit);
        }

        var docs = [];
        ids.sort(); // keep id in order, avoid deadlock
        return P.each(ids, function(id){
            return self.findById(id, fields, opts)
            .then(function(doc){
                // WARN: This is possible that doc is null due to index collection is not locked
                if(!!doc){
                    docs.push(doc);
                }
            });
        })
        .thenReturn(docs);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(ignores.indexOf(value) !== -1){
        throw new Error(&#x27;value &#x27; + value + &#x27; for key &#x27; + key + &#x27; is ignored in index&#x27;);
    }
    return value;
});
var indexValue = JSON.stringify(values);

return this.<span class="apidocCodeKeywordSpan">_findByIndex</span>(indexKey, indexValue, fields, opts);
};

proto.findOne = function(query, fields, opts){
opts = opts || {};
opts.limit = 1;
return this.find(query, fields, opts)
.then(function(docs){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._finishIndexTasks" id="apidoc.element.memdb-server.collection.prototype._finishIndexTasks">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_finishIndexTasks
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_finishIndexTasks = function (id){
    if(!this.pendingIndexTasks[id]){
        return;
    }
    // Save domain
    var d = process.domain;
    var self = this;
    return P.each(self.pendingIndexTasks[id], function(promise){
        return promise;
    })
    .finally(function(){
        delete self.pendingIndexTasks[id];
        // Restore domain
        process.domain = d;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return P.try(function(){
    return self.lock(id);
})
.then(function(){
    return self.shard.insert(self.conn._id, self._key(id), doc);
})
.then(function(){
    return self.<span class="apidocCodeKeywordSpan">_finishIndexTasks</span>(id);
})
.thenReturn(id);
};

proto.find = function(query, fields, opts){
if(typeof(query) === &#x27;number&#x27; || typeof(query) === &#x27;string&#x27;){
    return this.findById(query, fields, opts);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._indexCollectionName" id="apidoc.element.memdb-server.collection.prototype._indexCollectionName">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_indexCollectionName
        <span class="apidocSignatureSpan">(indexKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_indexCollectionName = function (indexKey){
    var keys = JSON.parse(indexKey).map(function(key){
        return utils.escapeField(key);
    });
    return &#x27;index.&#x27; + utils.escapeField(this.name) + &#x27;.&#x27; + keys.join(&#x27;.&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

proto._findByIndex = function(indexKey, indexValue, fields, opts){
opts = opts || {};
var self = this;

var indexCollection = this.conn.getCollection(this.<span class="apidocCodeKeywordSpan">_indexCollectionName</span>(indexKey), true
);

var nolock = opts.nolock;

return P.try(function(){
    opts.nolock = true; // force not using lock
    return indexCollection.findById(indexValue, &#x27;format ids&#x27;, opts);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._insertById" id="apidoc.element.memdb-server.collection.prototype._insertById">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_insertById
        <span class="apidocSignatureSpan">(id, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insertById = function (id, doc){
    if(!utils.isDict(doc)){
        throw new Error(&#x27;doc must be a dictionary&#x27;);
    }

    if(id === null || id === undefined){
        id = utils.uuid();
    }
    id = this._checkId(id);
    doc._id = id;

    var self = this;
    return P.try(function(){
        return self.lock(id);
    })
    .then(function(){
        return self.shard.insert(self.conn._id, self._key(id), doc);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    })
    .thenReturn(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

proto.close = function(){
    this.shard.removeListener(this.updateIndexEvent, this.onUpdateIndex);
};

proto.insert = function(docs){
    if(!Array.isArray(docs)){
        return this.<span class="apidocCodeKeywordSpan">_insertById</span>(docs &#x26;&#x26; docs._id, docs);
    }

    var self = this;
    return P.mapSeries(docs, function(doc){ //disable concurrent to avoid race condition
        return self._insertById(doc &#x26;&#x26; doc._id, doc);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._key" id="apidoc.element.memdb-server.collection.prototype._key">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_key
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_key = function (id){
    return this.name + &#x27;$&#x27; + id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doc._id = id;

    var self = this;
    return P.try(function(){
        return self.lock(id);
    })
    .then(function(){
        return self.shard.insert(self.conn._id, self.<span class="apidocCodeKeywordSpan">_key</span>(id), doc);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    })
    .thenReturn(id);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._removeById" id="apidoc.element.memdb-server.collection.prototype._removeById">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_removeById
        <span class="apidocSignatureSpan">(id, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_removeById = function (id, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.remove(self.conn._id, self._key(id), opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return self.find(query, &#x27;_id&#x27;);
})
.then(function(ret){
    if(!ret || ret.length === 0){
        return 0;
    }
    if(!Array.isArray(ret)){
        return self.<span class="apidocCodeKeywordSpan">_removeById</span>(ret._id, opts)
        .thenReturn(1);
    }
    return P.each(ret, function(doc){
        return self._removeById(doc._id, opts);
    })
    .thenReturn(ret.length);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype._updateById" id="apidoc.element.memdb-server.collection.prototype._updateById">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>_updateById
        <span class="apidocSignatureSpan">(id, modifier, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateById = function (id, modifier, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.update(self.conn._id, self._key(id), modifier, opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    // upsert
    if(typeof(query) === &#x27;string&#x27; || typeof(query) === &#x27;number&#x27;){
        query = {_id : query};
    }
    return self.insert(query)
    .then(function(id){
        return self.<span class="apidocCodeKeywordSpan">_updateById</span>(id, modifier, opts);
    })
    .thenReturn(1);
}

if(!Array.isArray(ret)){
    return self._updateById(ret._id, modifier, opts)
    .thenReturn(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.close" id="apidoc.element.memdb-server.collection.prototype.close">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (){
    this.shard.removeListener(this.updateIndexEvent, this.onUpdateIndex);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var proto = Connection.prototype;

proto.close = function(){
if(this.isDirty()){
    this.rollback();
}
for(var name in this.collections){
    this.collections[name].<span class="apidocCodeKeywordSpan">close</span>();
}
};

consts.collMethods.forEach(function(method){
proto[method] = function(name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.commitIndex" id="apidoc.element.memdb-server.collection.prototype.commitIndex">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>commitIndex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commitIndex = function (){
    var self = this;

    // must update in sorted order to avoid dead lock
    return P.each(Object.keys(this.changedIndexes).sort(), function(indexKey){
        var changedIndex = self.changedIndexes[indexKey];
        var config = self.config.indexes[indexKey];

        return P.each(Object.keys(changedIndex).sort(), function(indexValue){
            var changedIds = changedIndex[indexValue];

            return self.commitOneIndex(indexKey, indexValue, changedIds, config);
        });
    })
    .then(function(){
        self.changedIndexes = utils.forceHashMap();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};
});

proto.commit = function(){
var self = this;
return P.each(Object.keys(this.collections), function(name){
    var collection = self.collections[name];
    return collection.<span class="apidocCodeKeywordSpan">commitIndex</span>();
})
.then(function(){
    return self.shard.commit(self._id, Object.keys(self.lockedKeys));
})
.then(function(){
    self.lockedKeys = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.commitOneIndex" id="apidoc.element.memdb-server.collection.prototype.commitOneIndex">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>commitOneIndex
        <span class="apidocSignatureSpan">(indexKey, indexValue, changedIds, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commitOneIndex = function (indexKey, indexValue, changedIds, config){

    var indexCollection = this.conn.getCollection(this._indexCollectionName(indexKey), true);

    var modifier = {$pushAll : {ids : []}, $pullAll : {ids : []}};

    var countDelta = 0;
    for(var id in changedIds){
        if(changedIds[id] === 1){
            modifier.$pushAll.ids.push(id);
            countDelta++;
        }
        else{
            modifier.$pullAll.ids.push(id);
            countDelta--;
        }
    }

    var self = this;
    return P.try(function(){
        return indexCollection.find(indexValue, &#x27;ids&#x27;);
    })
    .then(function(ret){
        var oldCount = ret ? ret.ids.length : 0;

        var newCount = oldCount + countDelta;
        if(config.unique &#x26;&#x26; newCount &#x3e; 1){
            throw new Error(&#x27;duplicate value - &#x27; + indexValue + &#x27; for unique index - &#x27; + indexKey);
        }
        if(newCount &#x3e; config.maxCollision){
            throw new Error(&#x27;too many documents have value - &#x27; + indexValue + &#x27; for index - &#x27; + indexKey);
        }

        if(newCount &#x3e; 0){
            return indexCollection.update(indexValue, modifier, {upsert : true});
        }
        else if(newCount === 0){
            return indexCollection.remove(indexValue);
        }
        else{
            throw new Error(util.format(&#x27;index corrupted: %s %s, please rebuild index&#x27;, self.name, indexKey));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!config.unique){
    return;
}

return P.try(function(){
    if(oldValue !== null){
        return self.<span class="apidocCodeKeywordSpan">commitOneIndex</span>(indexKey, oldValue, changedIndex[oldValue], config
)
        .then(function(){
            delete changedIndex[oldValue];
        });
    }
})
.then(function(){
    if(newValue !== null){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.count" id="apidoc.element.memdb-server.collection.prototype.count">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>count
        <span class="apidocSignatureSpan">(query, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (query, opts){
    opts = opts || {};
    opts.count = true;
    var self = this;
    return P.try(function(){
        return self.find(query, null, opts);
    })
    .then(function(ret){
        if(typeof(ret) === &#x27;number&#x27;){
            return ret;
        }
        else if(Array.isArray(ret)){
            return ret.length;
        }
        else if(!ret){
            return 0;
        }
        throw new Error(&#x27;Unexpected find result - &#x27; + ret);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.find" id="apidoc.element.memdb-server.collection.prototype.find">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>find
        <span class="apidocSignatureSpan">(query, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (query, fields, opts){
    if(typeof(query) === &#x27;number&#x27; || typeof(query) === &#x27;string&#x27;){
        return this.findById(query, fields, opts);
    }

    if(!utils.isDict(query)){
        throw new Error(&#x27;invalid query&#x27;);
    }

    if(query.hasOwnProperty(&#x27;_id&#x27;)){
        return this.findById(query._id, fields, opts)
        .then(function(doc){
            if(!doc){
                return [];
            }
            return [doc];
        });
    }

    var keys = Object.keys(query).sort();
    if(keys.length === 0){
        throw new Error(&#x27;You must specify query key&#x27;);
    }

    var indexKey = JSON.stringify(keys);

    var indexConfig = this.config.indexes &#x26;&#x26; this.config.indexes[indexKey];
    if(!indexConfig){
        throw new Error(&#x27;No index configured for keys - &#x27; + indexKey);
    }

    var valueIgnore = indexConfig.valueIgnore || {};
    var values = keys.map(function(key){
        var value = query[key];
        if(value === null || value === undefined){
            throw new Error(&#x27;query value can not be null or undefined&#x27;);
        }
        var ignores = valueIgnore[key] || [];
        if(ignores.indexOf(value) !== -1){
            throw new Error(&#x27;value &#x27; + value + &#x27; for key &#x27; + key + &#x27; is ignored in index&#x27;);
        }
        return value;
    });
    var indexValue = JSON.stringify(values);

    return this._findByIndex(indexKey, indexValue, fields, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return this._findByIndex(indexKey, indexValue, fields, opts);
};

proto.findOne = function(query, fields, opts){
opts = opts || {};
opts.limit = 1;
return this.<span class="apidocCodeKeywordSpan">find</span>(query, fields, opts)
.then(function(docs){
    if(!Array.isArray(docs)){
        return docs;
    }
    if(docs.length === 0){
        return null;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.findById" id="apidoc.element.memdb-server.collection.prototype.findById">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findById
        <span class="apidocSignatureSpan">(id, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findById = function (id, fields, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        if(opts &#x26;&#x26; opts.readonly){
            return self.shard.findReadOnly(self.conn._id, self._key(id), fields);
        }

        return P.try(function(){
            if(opts &#x26;&#x26; opts.nolock){
                return;
            }
            return self.lock(id);
        })
        .then(function(){
            return self.shard.find(self.conn._id, self._key(id), fields, opts);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return self._finishIndexTasks(id);
})
.thenReturn(id);
};

proto.find = function(query, fields, opts){
if(typeof(query) === &#x27;number&#x27; || typeof(query) === &#x27;string&#x27;){
    return this.<span class="apidocCodeKeywordSpan">findById</span>(query, fields, opts);
}

if(!utils.isDict(query)){
    throw new Error(&#x27;invalid query&#x27;);
}

if(query.hasOwnProperty(&#x27;_id&#x27;)){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.findByIdReadOnly" id="apidoc.element.memdb-server.collection.prototype.findByIdReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findByIdReadOnly
        <span class="apidocSignatureSpan">(id, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findByIdReadOnly = function (id, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.findById(id, fields, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.findOne" id="apidoc.element.memdb-server.collection.prototype.findOne">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findOne
        <span class="apidocSignatureSpan">(query, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOne = function (query, fields, opts){
    opts = opts || {};
    opts.limit = 1;
    return this.find(query, fields, opts)
    .then(function(docs){
        if(!Array.isArray(docs)){
            return docs;
        }
        if(docs.length === 0){
            return null;
        }
        return docs[0];
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opts.readonly = true;
    return this.find(query, fields, opts);
};

proto.findOneReadOnly = function(query, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.<span class="apidocCodeKeywordSpan">findOne</span>(query, fields, opts);
};

proto.findByIdReadOnly = function(id, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.findById(id, fields, opts);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.findOneReadOnly" id="apidoc.element.memdb-server.collection.prototype.findOneReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findOneReadOnly
        <span class="apidocSignatureSpan">(query, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneReadOnly = function (query, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.findOne(query, fields, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.findReadOnly" id="apidoc.element.memdb-server.collection.prototype.findReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>findReadOnly
        <span class="apidocSignatureSpan">(query, fields, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findReadOnly = function (query, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.find(query, fields, opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

proto.findById = function(id, fields, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
if(opts &#x26;&#x26; opts.readonly){
    return self.shard.<span class="apidocCodeKeywordSpan">findReadOnly</span>(self.conn._id, self._key(id), fields);
}

return P.try(function(){
    if(opts &#x26;&#x26; opts.nolock){
        return;
    }
    return self.lock(id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.insert" id="apidoc.element.memdb-server.collection.prototype.insert">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>insert
        <span class="apidocSignatureSpan">(docs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (docs){
    if(!Array.isArray(docs)){
        return this._insertById(docs &#x26;&#x26; docs._id, docs);
    }

    var self = this;
    return P.mapSeries(docs, function(doc){ //disable concurrent to avoid race condition
        return self._insertById(doc &#x26;&#x26; doc._id, doc);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doc._id = id;

    var self = this;
    return P.try(function(){
        return self.lock(id);
    })
    .then(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">insert</span>(self.conn._id, self._key(id), doc);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    })
    .thenReturn(id);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.lock" id="apidoc.element.memdb-server.collection.prototype.lock">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>lock
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (id){
    id = this._checkId(id);
    if(this.shard.isLocked(this.conn._id, this._key(id))){
        return;
    }

    var self = this;
    return this.shard.lock(this.conn._id, this._key(id))
    .then(function(ret){
        self.emit(&#x27;lock&#x27;, id);
        return ret;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    id = utils.uuid();
}
id = this._checkId(id);
doc._id = id;

var self = this;
return P.try(function(){
    return self.<span class="apidocCodeKeywordSpan">lock</span>(id);
})
.then(function(){
    return self.shard.insert(self.conn._id, self._key(id), doc);
})
.then(function(){
    return self._finishIndexTasks(id);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.onUpdateIndex" id="apidoc.element.memdb-server.collection.prototype.onUpdateIndex">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>onUpdateIndex
        <span class="apidocSignatureSpan">(id, indexKey, oldValue, newValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onUpdateIndex = function (id, indexKey, oldValue, newValue){
    this.logger.debug(&#x27;onUpdateIndex(%s, %s, %s, %s)&#x27;, id, indexKey, oldValue, newValue);

    var self = this;
    var promise = P.try(function(){

        var config = self.config.indexes[indexKey];
        if(!config){
            throw new Error(&#x27;index - &#x27; + indexKey + &#x27; not configured&#x27;);
        }
        if(!self.changedIndexes[indexKey]){
            self.changedIndexes[indexKey] = utils.forceHashMap();
        }

        var changedIndex = self.changedIndexes[indexKey];

        if(oldValue !== null){
            if(!changedIndex[oldValue]){
                changedIndex[oldValue] = utils.forceHashMap();
            }
            if(changedIndex[oldValue][id] === 1){
                delete changedIndex[oldValue][id];
            }
            else{
                changedIndex[oldValue][id] = -1;
            }
        }
        if(newValue !== null){
            if(!changedIndex[newValue]){
                changedIndex[newValue] = utils.forceHashMap();
            }
            if(changedIndex[newValue][id] === -1){
                delete changedIndex[oldValue][id];
            }
            else{
                changedIndex[newValue][id] = 1;
            }
        }

        if(!config.unique){
            return;
        }

        return P.try(function(){
            if(oldValue !== null){
                return self.commitOneIndex(indexKey, oldValue, changedIndex[oldValue], config)
                .then(function(){
                    delete changedIndex[oldValue];
                });
            }
        })
        .then(function(){
            if(newValue !== null){
                return self.commitOneIndex(indexKey, newValue, changedIndex[newValue], config)
                .then(function(){
                    delete changedIndex[newValue];
                });
            }
        });
    });

    if(!this.pendingIndexTasks[id]){
        this.pendingIndexTasks[id] = [];
    }
    this.pendingIndexTasks[id].push(promise);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.remove" id="apidoc.element.memdb-server.collection.prototype.remove">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>remove
        <span class="apidocSignatureSpan">(query, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (query, opts){
    var self = this;
    return P.try(function(){
        return self.find(query, &#x27;_id&#x27;);
    })
    .then(function(ret){
        if(!ret || ret.length === 0){
            return 0;
        }
        if(!Array.isArray(ret)){
            return self._removeById(ret._id, opts)
            .thenReturn(1);
        }
        return P.each(ret, function(doc){
            return self._removeById(doc._id, opts);
        })
        .thenReturn(ret.length);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._removeById = function(id, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">remove</span>(self.conn._id, self._key(id), opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.lock = function(id){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.rollbackIndex" id="apidoc.element.memdb-server.collection.prototype.rollbackIndex">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>rollbackIndex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollbackIndex = function (){
    this.changedIndexes = utils.forceHashMap();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

// sync method
proto.rollback = function(){
var self = this;
Object.keys(this.collections).forEach(function(name){
    self.collections[name].<span class="apidocCodeKeywordSpan">rollbackIndex</span>();
});

this.shard.rollback(this._id, Object.keys(this.lockedKeys));
this.lockedKeys = {};

this.logger.debug(&#x27;[conn:%s] rolledback&#x27;, this._id);
return true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.collection.prototype.update" id="apidoc.element.memdb-server.collection.prototype.update">
        function <span class="apidocSignatureSpan">memdb-server.collection.prototype.</span>update
        <span class="apidocSignatureSpan">(query, modifier, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (query, modifier, opts){
    opts = opts || {};
    var self = this;

    return P.try(function(){
        return self.find(query, &#x27;_id&#x27;);
    })
    .then(function(ret){
        if(!ret || ret.length === 0){
            if(!opts.upsert){
                return 0;
            }
            // upsert
            if(typeof(query) === &#x27;string&#x27; || typeof(query) === &#x27;number&#x27;){
                query = {_id : query};
            }
            return self.insert(query)
            .then(function(id){
                return self._updateById(id, modifier, opts);
            })
            .thenReturn(1);
        }

        if(!Array.isArray(ret)){
            return self._updateById(ret._id, modifier, opts)
            .thenReturn(1);
        }
        return P.each(ret, function(doc){
            return self._updateById(doc._id, modifier, opts);
        })
        .thenReturn(ret.length);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._updateById = function(id, modifier, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">update</span>(self.conn._id, self._key(id), modifier, opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.remove = function(query, opts){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.config" id="apidoc.module.memdb-server.config">module memdb-server.config</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.config.clusterConfig" id="apidoc.element.memdb-server.config.clusterConfig">
        function <span class="apidocSignatureSpan">memdb-server.config.</span>clusterConfig
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clusterConfig = function (){
    return _config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.config.getShardIds" id="apidoc.element.memdb-server.config.getShardIds">
        function <span class="apidocSignatureSpan">memdb-server.config.</span>getShardIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getShardIds = function (){
    if(!_config){
        throw new Error(&#x27;please config.init first&#x27;);
    }
    return Object.keys(_config.shards);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.config.init" id="apidoc.element.memdb-server.config.init">
        function <span class="apidocSignatureSpan">memdb-server.config.</span>init
        <span class="apidocSignatureSpan">(confPath, shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (confPath, shardId){
    var searchPaths = [];
    var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;

    var localDataPath = path.join(homePath, &#x27;.memdb&#x27;);
    mkdirp(localDataPath);

    searchPaths = confPath ? [confPath] : [path.join(homePath, &#x27;.memdb/memdb.conf.js&#x27;), &#x27;/etc/memdb.conf.js&#x27;];

    var conf = null;
    for(var i=0; i&#x3c;searchPaths.length; i++){
        if(fs.existsSync(searchPaths[i])){
            confPath = path.resolve(searchPaths[i]);
            conf = require(confPath);
            exports.path = confPath;
            break;
        }
    }
    if(!conf){
        if(confPath){
            throw new Error(&#x27;config file not found - &#x27; + searchPaths);
        }

        // copy and load default config
        var confTemplatePath = path.join(__dirname, &#x27;../memdb.conf.js&#x27;);
        var defaultConfPath = path.join(localDataPath, &#x27;memdb.conf.js&#x27;);
        fs.copySync(confTemplatePath, defaultConfPath);

        conf = require(defaultConfPath);
    }

    // Configure promise
    if(conf.promise &#x26;&#x26; conf.promise.longStackTraces){
        P.longStackTraces();
    }

    // Configure log
    var logConf = conf.log || {};

    var logPath = logConf.path || path.join(localDataPath, &#x27;log&#x27;);
    mkdirp(logPath);

    console.log(&#x27;log path: %s&#x27;, logPath);
    memdbLogger.configure(path.join(__dirname, &#x27;log4js.json&#x27;), {shardId : shardId || &#x27;$&#x27;, base : logPath});

    var level = logConf.level || &#x27;INFO&#x27;;
    memdbLogger.setGlobalLogLevel(memdbLogger.levels[level]);

    // heapdump
    if(conf.heapdump){
        require(&#x27;heapdump&#x27;);
    }

    _config = conf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.config.shardConfig" id="apidoc.element.memdb-server.config.shardConfig">
        function <span class="apidocSignatureSpan">memdb-server.config.</span>shardConfig
        <span class="apidocSignatureSpan">(shardId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shardConfig = function (shardId){
    if(!_config){
        throw new Error(&#x27;please config.init first&#x27;);
    }

    var conf = utils.clone(_config);

    var shardConf = conf.shards &#x26;&#x26; conf.shards[shardId];
    if(!shardConf){
        throw new Error(&#x27;shard &#x27; + shardId + &#x27; not configured&#x27;);
    }
    // Override shard specific config
    for(var key in shardConf){
        conf[key] = shardConf[key];
    }

    conf.shardId = shardId;
    return conf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.connection" id="apidoc.module.memdb-server.connection">module memdb-server.connection</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.connection.connection" id="apidoc.element.memdb-server.connection.connection">
        function <span class="apidocSignatureSpan">memdb-server.</span>connection
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connection = function (opts){
    opts = opts || {};

    this._id = opts._id;
    this.shard = opts.shard;

    this.config = opts.config || {};
    this.collections = {};

    this.lockedKeys = utils.forceHashMap();

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.connection.prototype" id="apidoc.module.memdb-server.connection.prototype">module memdb-server.connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.close" id="apidoc.element.memdb-server.connection.prototype.close">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>close
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (){
    if(this.isDirty()){
        this.rollback();
    }
    for(var name in this.collections){
        this.collections[name].close();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var proto = Connection.prototype;

proto.close = function(){
if(this.isDirty()){
    this.rollback();
}
for(var name in this.collections){
    this.collections[name].<span class="apidocCodeKeywordSpan">close</span>();
}
};

consts.collMethods.forEach(function(method){
proto[method] = function(name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.commit" id="apidoc.element.memdb-server.connection.prototype.commit">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>commit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (){
    var self = this;
    return P.each(Object.keys(this.collections), function(name){
        var collection = self.collections[name];
        return collection.commitIndex();
    })
    .then(function(){
        return self.shard.commit(self._id, Object.keys(self.lockedKeys));
    })
    .then(function(){
        self.lockedKeys = {};

        self.logger.debug(&#x27;[conn:%s] commited&#x27;, self._id);
        return true;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.commit = function(){
var self = this;
return P.each(Object.keys(this.collections), function(name){
    var collection = self.collections[name];
    return collection.commitIndex();
})
.then(function(){
    return self.shard.<span class="apidocCodeKeywordSpan">commit</span>(self._id, Object.keys(self.lockedKeys));
})
.then(function(){
    self.lockedKeys = {};

    self.logger.debug(&#x27;[conn:%s] commited&#x27;, self._id);
    return true;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.count" id="apidoc.element.memdb-server.connection.prototype.count">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>count
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.find" id="apidoc.element.memdb-server.connection.prototype.find">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>find
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return this._findByIndex(indexKey, indexValue, fields, opts);
};

proto.findOne = function(query, fields, opts){
opts = opts || {};
opts.limit = 1;
return this.<span class="apidocCodeKeywordSpan">find</span>(query, fields, opts)
.then(function(docs){
    if(!Array.isArray(docs)){
        return docs;
    }
    if(docs.length === 0){
        return null;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.findById" id="apidoc.element.memdb-server.connection.prototype.findById">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findById
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findById = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return self._finishIndexTasks(id);
})
.thenReturn(id);
};

proto.find = function(query, fields, opts){
if(typeof(query) === &#x27;number&#x27; || typeof(query) === &#x27;string&#x27;){
    return this.<span class="apidocCodeKeywordSpan">findById</span>(query, fields, opts);
}

if(!utils.isDict(query)){
    throw new Error(&#x27;invalid query&#x27;);
}

if(query.hasOwnProperty(&#x27;_id&#x27;)){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.findByIdReadOnly" id="apidoc.element.memdb-server.connection.prototype.findByIdReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findByIdReadOnly
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findByIdReadOnly = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.findOne" id="apidoc.element.memdb-server.connection.prototype.findOne">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findOne
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOne = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    opts.readonly = true;
    return this.find(query, fields, opts);
};

proto.findOneReadOnly = function(query, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.<span class="apidocCodeKeywordSpan">findOne</span>(query, fields, opts);
};

proto.findByIdReadOnly = function(id, fields, opts){
    opts = opts || {};
    opts.readonly = true;
    return this.findById(id, fields, opts);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.findOneReadOnly" id="apidoc.element.memdb-server.connection.prototype.findOneReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findOneReadOnly
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneReadOnly = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.findReadOnly" id="apidoc.element.memdb-server.connection.prototype.findReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>findReadOnly
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findReadOnly = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

proto.findById = function(id, fields, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
if(opts &#x26;&#x26; opts.readonly){
    return self.shard.<span class="apidocCodeKeywordSpan">findReadOnly</span>(self.conn._id, self._key(id), fields);
}

return P.try(function(){
    if(opts &#x26;&#x26; opts.nolock){
        return;
    }
    return self.lock(id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.flushBackend" id="apidoc.element.memdb-server.connection.prototype.flushBackend">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>flushBackend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushBackend = function (){
    return this.shard.flushBackend(this._id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.lockedKeys = {};

    this.logger.debug(&#x27;[conn:%s] rolledback&#x27;, this._id);
    return true;
};

proto.flushBackend = function(){
    return this.shard.<span class="apidocCodeKeywordSpan">flushBackend</span>(this._id);
};

// for internal use
proto.$unload = function(key){
    return this.shard.$unload(key);
};
// for internal use
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.getCollection" id="apidoc.element.memdb-server.connection.prototype.getCollection">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>getCollection
        <span class="apidocSignatureSpan">(name, isIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCollection = function (name, isIndex){
    if(!isIndex &#x26;&#x26; name &#x26;&#x26; name.indexOf(&#x27;index.&#x27;) === 0){
        throw new Error(&#x27;Collection name can not begin with &#x22;index.&#x22;&#x27;);
    }

    var self = this;
    if(!this.collections[name]){
        var collection = new Collection({
            name : name,
            shard : this.shard,
            conn : this,
            config : this.config.collections[name] || {},
        });

        collection.on(&#x27;lock&#x27;, function(id){
            var key = name + &#x27;$&#x27; + id;
            self.lockedKeys[key] = true;
        });

        this.collections[name] = collection;
    }
    return this.collections[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

proto._findByIndex = function(indexKey, indexValue, fields, opts){
opts = opts || {};
var self = this;

var indexCollection = this.conn.<span class="apidocCodeKeywordSpan">getCollection</span>(this._indexCollectionName(indexKey), true
);

var nolock = opts.nolock;

return P.try(function(){
    opts.nolock = true; // force not using lock
    return indexCollection.findById(indexValue, &#x27;format ids&#x27;, opts);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.insert" id="apidoc.element.memdb-server.connection.prototype.insert">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>insert
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doc._id = id;

    var self = this;
    return P.try(function(){
        return self.lock(id);
    })
    .then(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">insert</span>(self.conn._id, self._key(id), doc);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    })
    .thenReturn(id);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.isDirty" id="apidoc.element.memdb-server.connection.prototype.isDirty">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>isDirty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirty = function (){
    return Object.keys(this.lockedKeys).length &#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
};

var proto = Connection.prototype;

proto.close = function(){
    if(this.<span class="apidocCodeKeywordSpan">isDirty</span>()){
        this.rollback();
    }
    for(var name in this.collections){
        this.collections[name].close();
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.lock" id="apidoc.element.memdb-server.connection.prototype.lock">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>lock
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    id = utils.uuid();
}
id = this._checkId(id);
doc._id = id;

var self = this;
return P.try(function(){
    return self.<span class="apidocCodeKeywordSpan">lock</span>(id);
})
.then(function(){
    return self.shard.insert(self.conn._id, self._key(id), doc);
})
.then(function(){
    return self._finishIndexTasks(id);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.remove" id="apidoc.element.memdb-server.connection.prototype.remove">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._removeById = function(id, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">remove</span>(self.conn._id, self._key(id), opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.lock = function(id){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.rollback" id="apidoc.element.memdb-server.connection.prototype.rollback">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>rollback
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (){
    var self = this;
    Object.keys(this.collections).forEach(function(name){
        self.collections[name].rollbackIndex();
    });

    this.shard.rollback(this._id, Object.keys(this.lockedKeys));
    this.lockedKeys = {};

    this.logger.debug(&#x27;[conn:%s] rolledback&#x27;, this._id);
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
};

var proto = Connection.prototype;

proto.close = function(){
    if(this.isDirty()){
        this.<span class="apidocCodeKeywordSpan">rollback</span>();
    }
    for(var name in this.collections){
        this.collections[name].close();
    }
};

consts.collMethods.forEach(function(method){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.connection.prototype.update" id="apidoc.element.memdb-server.connection.prototype.update">
        function <span class="apidocSignatureSpan">memdb-server.connection.prototype.</span>update
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (name){
    var collection = this.getCollection(name);
    // remove &#x27;name&#x27; arg
    var args = [].slice.call(arguments, 1);

    this.logger.debug(&#x27;[conn:%s] %s.%s(%j)&#x27;, this._id, name, method, args);
    return collection[method].apply(collection, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._updateById = function(id, modifier, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">update</span>(self.conn._id, self._key(id), modifier, opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.remove = function(query, opts){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.database" id="apidoc.module.memdb-server.database">module memdb-server.database</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.database.database" id="apidoc.element.memdb-server.database.database">
        function <span class="apidocSignatureSpan">memdb-server.</span>database
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">database = function (opts){
    // clone since we want to modify it
    opts = utils.clone(opts) || {};

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);

    this.connections = utils.forceHashMap();
    this.connectionLock = new AsyncLock({Promise : P});

    this.dbWrappers = utils.forceHashMap(); //{connId : dbWrapper}

    this.opsCounter = utils.rateCounter();
    this.tpsCounter = utils.rateCounter();

    opts.slowQuery = opts.slowQuery || DEFAULT_SLOWQUERY;

    // Parse index config
    opts.collections = opts.collections || {};

    Object.keys(opts.collections).forEach(function(name){
        var collection = opts.collections[name];
        var indexes = {};
        (collection.indexes || []).forEach(function(index){
            if(!Array.isArray(index.keys)){
                index.keys = [index.keys];
            }
            var indexKey = JSON.stringify(index.keys.sort());
            if(indexes[indexKey]){
                throw new Error(&#x27;Duplicate index keys - &#x27; + indexKey);
            }

            delete index.keys;
            indexes[indexKey] = index;
        });
        collection.indexes = indexes;
    });

    this.logger.info(&#x27;parsed opts: %j&#x27;, opts);

    this.shard = new Shard(opts);

    this.config = opts;

    this.timeCounter = utils.timeCounter();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database.super_" id="apidoc.element.memdb-server.database.super_">
        function <span class="apidocSignatureSpan">memdb-server.database.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.database.prototype" id="apidoc.module.memdb-server.database.prototype">module memdb-server.database.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.database.prototype.connect" id="apidoc.element.memdb-server.database.prototype.connect">
        function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>connect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">connect = function (){
    var connId = utils.uuid();
    var opts = {
        _id : connId,
        shard : this.shard,
        config : this.config,
        logger : this.logger
    };
    var conn = new Connection(opts);
    this.connections[connId] = conn;

    var self = this;
    var dbWrapper = {};
    consts.collMethods.concat(consts.connMethods).forEach(function(method){
        dbWrapper[method] = function(){
            return self.execute(connId, method, [].slice.call(arguments));
        };
    });
    this.dbWrappers[connId] = dbWrapper;

    this.logger.info(&#x27;[conn:%s] connection created&#x27;, connId);
    return {
        connId : connId,
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            P.try(function(){
if(msg.method === &#x27;connect&#x27;){
    var clientVersion = msg.args[0];
    if(parseFloat(clientVersion) &#x3c; parseFloat(consts.minClientVersion)){
        throw new Error(&#x27;client version not supported, please upgrade&#x27;);
    }
    var connId = db.<span class="apidocCodeKeywordSpan">connect</span>().connId;
    connIds[connId] = true;
    return {
        connId : connId,
    };
}
if(!msg.connId){
    throw new Error(&#x27;connId is required&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database.prototype.disconnect" id="apidoc.element.memdb-server.database.prototype.disconnect">
        function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>disconnect
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (connId){
    var self = this;
    return P.try(function(){
        var conn = self.getConnection(connId);
        return self.execute(connId, &#x27;close&#x27;, [], {ignoreConcurrent : true});
    })
    .then(function(){
        delete self.connections[connId];
        delete self.dbWrappers[connId];
        self.logger.info(&#x27;[conn:%s] connection closed&#x27;, connId);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            connId : connId,
        };
    }
    if(!msg.connId){
        throw new Error(&#x27;connId is required&#x27;);
    }
    if(msg.method === &#x27;disconnect&#x27;){
        return db.<span class="apidocCodeKeywordSpan">disconnect</span>(msg.connId)
        .then(function(){
            delete connIds[msg.connId];
        });
    }
    return db.execute(msg.connId, msg.method, msg.args);
})
.then(function(ret){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database.prototype.execute" id="apidoc.element.memdb-server.database.prototype.execute">
        function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>execute
        <span class="apidocSignatureSpan">(connId, method, args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execute = function (connId, method, args, opts){
    opts = opts || {};
    var self = this;

    if(method[0] === &#x27;$&#x27;){ // Internal method (allow concurrent call)
        var conn = this.getConnection(connId);
        return conn[method].apply(conn, args);
    }

    if(method === &#x27;info&#x27;){
        return {
            connId : connId,
            ver : consts.version,
            uptime : process.uptime(),
            mem : process.memoryUsage(),
            // rate for last 1, 5, 15 minutes
            ops : [this.opsCounter.rate(60), this.opsCounter.rate(300), this.opsCounter.rate(900)],
            tps : [this.tpsCounter.rate(60), this.tpsCounter.rate(300), this.tpsCounter.rate(900)],
            lps : [this.shard.loadCounter.rate(60), this.shard.loadCounter.rate(300), this.shard.loadCounter.rate(900)],
            ups : [this.shard.unloadCounter.rate(60), this.shard.unloadCounter.rate(300), this.shard.unloadCounter.rate(900)],
            pps : [this.shard.persistentCounter.rate(60), this.shard.persistentCounter.rate(300), this.shard.persistentCounter.rate
(900)],
            counter : this.timeCounter.getCounts(),
        };
    }
    else if(method === &#x27;resetCounter&#x27;){
        this.opsCounter.reset();
        this.tpsCounter.reset();
        this.shard.loadCounter.reset();
        this.shard.unloadCounter.reset();
        this.shard.persistentCounter.reset();

        this.timeCounter.reset();
        return;
    }
    else if(method === &#x27;eval&#x27;){
        var script = args[0] || &#x27;&#x27;;
        var sandbox = args[1] || {};
        sandbox.require = require;
        sandbox.P = P;
        sandbox._ = _;
        sandbox.db = this.dbWrappers[connId];

        var context = vm.createContext(sandbox);

        return vm.runInContext(script, context);
    }

    // Query in the same connection must execute in series
    // This is usually a client bug here
    if(this.connectionLock.isBusy(connId) &#x26;&#x26; !opts.ignoreConcurrent){
        var err = new Error(util.format(&#x27;[conn:%s] concurrent query on same connection. %s(%j)&#x27;, connId, method, args));
        this.logger.error(err);
        throw err;
    }

    // Ensure series execution in same connection
    return this.connectionLock.acquire(connId, function(cb){
        self.logger.debug(&#x27;[conn:%s] start %s(%j)...&#x27;, connId, method, args);
        if(method === &#x27;commit&#x27; || method === &#x27;rollback&#x27;){
            self.tpsCounter.inc();
        }
        else{
            self.opsCounter.inc();
        }

        var hrtimer = utils.hrtimer(true);
        var conn = null;

        return P.try(function(){
            conn = self.getConnection(connId);

            var func = conn[method];
            if(typeof(func) !== &#x27;function&#x27;){
                throw new Error(&#x27;unsupported command - &#x27; + method);
            }
            return func.apply(conn, args);
        })
        .then(function(ret){
            var timespan = hrtimer.stop();
            var level = timespan &#x3c; self.config.slowQuery ? &#x27;info&#x27; : &#x27;warn&#x27;; // warn slow query
            self.logger[level](&#x27;[conn:%s] %s(%j) =&#x3e; %j (%sms)&#x27;, connId, method, args, ret, timespan);

            var category = method;
            if(consts.collMethods.indexOf(method) !== -1){
                category += &#x27;:&#x27; + args[0];
            }
            self.timeCounter.add(category, timespan);

            return ret;
        }, function(err){
            var timespan = hrtimer.stop();
            self.logger.error(&#x27;[conn:%s] %s(%j) =&#x3e; %s (%sms)&#x27;, connId, method, args, err.stack ? err.stack : err, timespan);

            if(conn){
                conn.rollback();
            }

            // Rethrow to client
            throw err;
        })
        .nodeify(cb);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var conn = new Connection(opts);
this.connections[connId] = conn;

var self = this;
var dbWrapper = {};
consts.collMethods.concat(consts.connMethods).forEach(function(method){
    dbWrapper[method] = function(){
        return self.<span class="apidocCodeKeywordSpan">execute</span>(connId, method, [].slice.call(arguments));
    };
});
this.dbWrappers[connId] = dbWrapper;

this.logger.info(&#x27;[conn:%s] connection created&#x27;, connId);
return {
    connId : connId,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database.prototype.getConnection" id="apidoc.element.memdb-server.database.prototype.getConnection">
        function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>getConnection
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConnection = function (id){
    var conn = this.connections[id];
    if(!conn){
        throw new Error(&#x27;connection &#x27; + id + &#x27; not exist&#x27;);
    }
    return conn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    connId : connId,
};
};

proto.disconnect = function(connId){
var self = this;
return P.try(function(){
    var conn = self.<span class="apidocCodeKeywordSpan">getConnection</span>(connId);
    return self.execute(connId, &#x27;close&#x27;, [], {ignoreConcurrent : true});
})
.then(function(){
    delete self.connections[connId];
    delete self.dbWrappers[connId];
    self.logger.info(&#x27;[conn:%s] connection closed&#x27;, connId);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database.prototype.start" id="apidoc.element.memdb-server.database.prototype.start">
        function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (){
    var self = this;
    return this.shard.start()
    .then(function(){
        self.logger.info(&#x27;database started&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.database.prototype.stop" id="apidoc.element.memdb-server.database.prototype.stop">
        function <span class="apidocSignatureSpan">memdb-server.database.prototype.</span>stop
        <span class="apidocSignatureSpan">(force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (force){
    var self = this;

    this.opsCounter.stop();
    this.tpsCounter.stop();

    return P.try(function(){
        // Make sure no new request come anymore

        // Wait for all operations finish
        return utils.waitUntil(function(){
            return !self.connectionLock.isBusy();
        });
    })
    .then(function(){
        self.logger.debug(&#x27;all requests finished&#x27;);
        return self.shard.stop(force);
    })
    .then(function(){
        self.logger.info(&#x27;database stoped&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.logger.info(&#x27;database started&#x27;);
    });
};

proto.stop = function(force){
    var self = this;

    this.opsCounter.<span class="apidocCodeKeywordSpan">stop</span>();
    this.tpsCounter.stop();

    return P.try(function(){
// Make sure no new request come anymore

// Wait for all operations finish
return utils.waitUntil(function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.document" id="apidoc.module.memdb-server.document">module memdb-server.document</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.document.document" id="apidoc.element.memdb-server.document.document">
        function <span class="apidocSignatureSpan">memdb-server.</span>document
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">document = function (opts){ //jshint ignore:line
    opts = opts || {};

    if(!opts.hasOwnProperty(&#x27;_id&#x27;)){
        throw new Error(&#x27;_id is not specified&#x27;);
    }
    this._id = opts._id;

    var doc = opts.doc || null;
    if(typeof(doc) !== &#x27;object&#x27;){
        throw new Error(&#x27;doc must be object&#x27;);
    }
    if(!!doc){
        doc._id = this._id;
    }

    this.commited = doc;
    this.changed = undefined; // undefined means no change, while null means removed
    this.connId = null; // Connection that hold the document lock

    this.locker = opts.locker;
    this.lockKey = opts.lockKey;
    if(!this.locker){
        this.locker = new AsyncLock({
                            Promise : P,
                            timeout : opts.lockTimeout || DEFAULT_LOCK_TIMEOUT
                            });
        this.lockKey = &#x27;&#x27;;
    }

    this.releaseCallback = null;

    this.indexes = opts.indexes || {};

    this.savedIndexValues = {}; //{indexKey : indexValue}

    EventEmitter.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.super_" id="apidoc.element.memdb-server.document.super_">
        function <span class="apidocSignatureSpan">memdb-server.document.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.document.prototype" id="apidoc.module.memdb-server.document.prototype">module memdb-server.document.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype._getChanged" id="apidoc.element.memdb-server.document.prototype._getChanged">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_getChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getChanged = function (){
    return this.changed !== undefined ? this.changed : this.commited;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

util.inherits(Document, EventEmitter);

var proto = Document.prototype;

proto.find = function(connId, fields){
var doc = this.isLocked(connId) ? this.<span class="apidocCodeKeywordSpan">_getChanged</span>() : this.commited;

if(doc === null){
    return null;
}

if(!fields){
    return doc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype._getCommited" id="apidoc.element.memdb-server.document.prototype._getCommited">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_getCommited
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getCommited = function (){
    return this.commited;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// internal method, not concurrency safe
proto._persistent = function(key){
if(!this.commitedKeys.hasOwnProperty(key)){
    return; // no change
}

var doc = this._doc(key).<span class="apidocCodeKeywordSpan">_getCommited</span>();
var ver = this.commitedKeys[key]; // get current version

var self = this;
var res = this._resolveKey(key);

return this.backend.set(res.name, res.id, doc)
.then(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype._getIndexValue" id="apidoc.element.memdb-server.document.prototype._getIndexValue">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_getIndexValue
        <span class="apidocSignatureSpan">(indexKey, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getIndexValue = function (indexKey, opts){
    opts = opts || {};

    var self = this;
    var indexValue = JSON.parse(indexKey).sort().map(function(key){
        var doc = self._getChanged();
        var value = !!doc ? doc[key] : undefined;
        // null and undefined is not included in index
        if(value === null || value === undefined){
            return undefined;
        }
        if([&#x27;number&#x27;, &#x27;string&#x27;, &#x27;boolean&#x27;].indexOf(typeof(value)) === -1){
            throw new Error(&#x27;invalid value for indexed key &#x27; + indexKey);
        }
        var ignores = opts.valueIgnore ? opts.valueIgnore[key] || [] : [];
        if(ignores.indexOf(value) !== -1){
            return undefined;
        }
        return value;
    });

    // Return null if one of the value is undefined
    if(indexValue.indexOf(undefined) !== -1){
        return null;
    }
    return JSON.stringify(indexValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto.modify = function(connId, cmd, param){
this.ensureLocked(connId);

for(var indexKey in this.indexes){
    if(!this.savedIndexValues.hasOwnProperty(indexKey)){
        this.savedIndexValues[indexKey] = this.<span class="apidocCodeKeywordSpan">_getIndexValue</span>(indexKey, this.indexes[
indexKey]);
    }
}

var modifyFunc = modifier[cmd];
if(typeof(modifyFunc) !== &#x27;function&#x27;){
    throw new Error(&#x27;invalid modifier - &#x27; + cmd);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype._unlock" id="apidoc.element.memdb-server.document.prototype._unlock">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_unlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unlock = function (){
    if(this.connId === null){
        return;
    }

    this.connId = null;
    var releaseCallback = this.releaseCallback;
    this.releaseCallback = null;

    releaseCallback();

    this.emit(&#x27;unlock&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(this.changed !== undefined){
    this.commited = this.changed;
}
this.changed = undefined;

this.emit(&#x27;commit&#x27;);
this.<span class="apidocCodeKeywordSpan">_unlock</span>();
};

proto.rollback = function(connId){
this.ensureLocked(connId);

this.changed = undefined;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype._waitUnlock" id="apidoc.element.memdb-server.document.prototype._waitUnlock">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>_waitUnlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_waitUnlock = function (){
    var deferred = P.defer();
    var self = this;
    this.locker.acquire(this.lockKey, function(){
        deferred.resolve();
    })
    .catch(function(err){
        deferred.reject(new Error(&#x27;doc._waitUnlock failed - &#x27; + self.lockKey));
    });
    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.logger.debug(&#x27;start unload %s&#x27;, key);

var doc = this.docs[key];

return P.bind(this)
.then(function(){
    // Wait all existing lock release
    return doc.<span class="apidocCodeKeywordSpan">_waitUnlock</span>();
})
.then(function(){
    // Persistent immediately
    return this._persistent(key);
})
.then(function(){
    if(!this.config.disableSlave){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.commit" id="apidoc.element.memdb-server.document.prototype.commit">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>commit
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (connId){
    this.ensureLocked(connId);

    if(this.changed !== undefined){
        this.commited = this.changed;
    }
    this.changed = undefined;

    this.emit(&#x27;commit&#x27;);
    this._unlock();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.commit = function(){
var self = this;
return P.each(Object.keys(this.collections), function(name){
    var collection = self.collections[name];
    return collection.commitIndex();
})
.then(function(){
    return self.shard.<span class="apidocCodeKeywordSpan">commit</span>(self._id, Object.keys(self.lockedKeys));
})
.then(function(){
    self.lockedKeys = {};

    self.logger.debug(&#x27;[conn:%s] commited&#x27;, self._id);
    return true;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.ensureLocked" id="apidoc.element.memdb-server.document.prototype.ensureLocked">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>ensureLocked
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureLocked = function (connId){
    if(!this.isLocked(connId)){
        throw new Error(&#x27;doc not locked by &#x27; + connId);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var cmd in modifier){
        this.modify(connId, cmd, modifier[cmd]);
    }
}
};

proto.modify = function(connId, cmd, param){
this.<span class="apidocCodeKeywordSpan">ensureLocked</span>(connId);

for(var indexKey in this.indexes){
    if(!this.savedIndexValues.hasOwnProperty(indexKey)){
        this.savedIndexValues[indexKey] = this._getIndexValue(indexKey, this.indexes[indexKey]);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.exists" id="apidoc.element.memdb-server.document.prototype.exists">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>exists
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (connId){
    return this.isLocked(connId) ? this._getChanged() !== null: this.commited !== null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.find" id="apidoc.element.memdb-server.document.prototype.find">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>find
        <span class="apidocSignatureSpan">(connId, fields)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (connId, fields){
    var doc = this.isLocked(connId) ? this._getChanged() : this.commited;

    if(doc === null){
        return null;
    }

    if(!fields){
        return doc;
    }

    var includeFields = [], excludeFields = [];

    if(typeof(fields) === &#x27;string&#x27;){
        includeFields = fields.split(&#x27; &#x27;);
    }
    else if(typeof(fields) === &#x27;object&#x27;){
        for(var field in fields){
            if(!!fields[field]){
                includeFields.push(field);
            }
            else{
                excludeFields.push(field);
            }
        }
        if(includeFields.length &#x3e; 0 &#x26;&#x26; excludeFields.length &#x3e; 0){
            throw new Error(&#x27;Can not specify both include and exclude fields&#x27;);
        }
    }

    var ret = null;
    if(includeFields.length &#x3e; 0){
        ret = {};
        includeFields.forEach(function(field){
            if(doc.hasOwnProperty(field)){
                ret[field] = doc[field];
            }
        });
        ret._id = this._id;
    }
    else if(excludeFields.length &#x3e; 0){
        ret = {};
        for(var key in doc){
            ret[key] = doc[key];
        }
        excludeFields.forEach(function(key){
            delete ret[key];
        });
    }
    else{
        ret = doc;
    }

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return this._findByIndex(indexKey, indexValue, fields, opts);
};

proto.findOne = function(query, fields, opts){
opts = opts || {};
opts.limit = 1;
return this.<span class="apidocCodeKeywordSpan">find</span>(query, fields, opts)
.then(function(docs){
    if(!Array.isArray(docs)){
        return docs;
    }
    if(docs.length === 0){
        return null;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.insert" id="apidoc.element.memdb-server.document.prototype.insert">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>insert
        <span class="apidocSignatureSpan">(connId, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (connId, doc){
    this.modify(connId, &#x27;$insert&#x27;,  doc);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doc._id = id;

    var self = this;
    return P.try(function(){
        return self.lock(id);
    })
    .then(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">insert</span>(self.conn._id, self._key(id), doc);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    })
    .thenReturn(id);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.isFree" id="apidoc.element.memdb-server.document.prototype.isFree">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>isFree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFree = function (){
    return this.connId === null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto.find = function(connId, key, fields){
    this._ensureState(STATE.RUNNING);
    var self = this;

    if(this.docs[key]){ //already loaded
if(this.docs[key].<span class="apidocCodeKeywordSpan">isFree</span>()){
    // restart idle timer if doc doesn&#x27;t locked by anyone
    this._cancelIdleTimeout(key);
    this._startIdleTimeout(key);
}

var ret = this.docs[key].find(connId, fields);
self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.isLocked" id="apidoc.element.memdb-server.document.prototype.isLocked">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>isLocked
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLocked = function (connId){
    return this.connId === connId &#x26;&#x26; connId !== null &#x26;&#x26; connId !== undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function(){
    return self._finishIndexTasks(id);
});
};

proto.lock = function(id){
id = this._checkId(id);
if(this.shard.<span class="apidocCodeKeywordSpan">isLocked</span>(this.conn._id, this._key(id))){
    return;
}

var self = this;
return this.shard.lock(this.conn._id, this._key(id))
.then(function(ret){
    self.emit(&#x27;lock&#x27;, id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.lock" id="apidoc.element.memdb-server.document.prototype.lock">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>lock
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (connId){
    if(connId === null || connId === undefined){
        throw new Error(&#x27;connId is null&#x27;);
    }

    var deferred = P.defer();
    if(this.isLocked(connId)){
        deferred.resolve();
    }
    else{
        var self = this;
        this.locker.acquire(this.lockKey, function(release){
            self.connId = connId;
            self.releaseCallback = release;

            self.emit(&#x27;lock&#x27;);
            deferred.resolve();
        })
        .catch(function(err){
            if(!deferred.isResolved()){
                deferred.reject(new Error(&#x27;doc.lock failed - &#x27; + self.lockKey));
            }
        });
    }
    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    id = utils.uuid();
}
id = this._checkId(id);
doc._id = id;

var self = this;
return P.try(function(){
    return self.<span class="apidocCodeKeywordSpan">lock</span>(id);
})
.then(function(){
    return self.shard.insert(self.conn._id, self._key(id), doc);
})
.then(function(){
    return self._finishIndexTasks(id);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.modify" id="apidoc.element.memdb-server.document.prototype.modify">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>modify
        <span class="apidocSignatureSpan">(connId, cmd, param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modify = function (connId, cmd, param){
    this.ensureLocked(connId);

    for(var indexKey in this.indexes){
        if(!this.savedIndexValues.hasOwnProperty(indexKey)){
            this.savedIndexValues[indexKey] = this._getIndexValue(indexKey, this.indexes[indexKey]);
        }
    }

    var modifyFunc = modifier[cmd];
    if(typeof(modifyFunc) !== &#x27;function&#x27;){
        throw new Error(&#x27;invalid modifier - &#x27; + cmd);
    }

    if(this.changed === undefined){ //copy on write
        this.changed = utils.clone(this.commited);
    }

    this.changed = modifyFunc(this.changed, param);

    // id is immutable
    if(!!this.changed){
        this.changed._id = this._id;
    }

    for(indexKey in this.indexes){
        var value = this._getIndexValue(indexKey, this.indexes[indexKey]);

        if(value !== this.savedIndexValues[indexKey]){
            logger.trace(&#x27;%s.updateIndex(%s, %s, %s)&#x27;, this._id, indexKey, this.savedIndexValues[indexKey], value);
            this.emit(&#x27;updateIndex&#x27;, connId, indexKey, this.savedIndexValues[indexKey], value);

            this.savedIndexValues[indexKey] = value;
        }
    }

    logger.trace(&#x27;%s.modify(%s, %j) =&#x3e; %j&#x27;, this._id, cmd, param, this.changed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto.exists = function(connId){
    return this.isLocked(connId) ? this._getChanged() !== null: this.commited !== null;
};

proto.insert = function(connId, doc){
    this.<span class="apidocCodeKeywordSpan">modify</span>(connId, &#x27;$insert&#x27;,  doc);
};

proto.remove = function(connId){
    this.modify(connId, &#x27;$remove&#x27;);
};

proto.update = function(connId, modifier, opts){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.remove" id="apidoc.element.memdb-server.document.prototype.remove">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>remove
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (connId){
    this.modify(connId, &#x27;$remove&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._removeById = function(id, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">remove</span>(self.conn._id, self._key(id), opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.lock = function(id){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.rollback" id="apidoc.element.memdb-server.document.prototype.rollback">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>rollback
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (connId){
    this.ensureLocked(connId);

    this.changed = undefined;

    this.savedIndexValues = {};

    this.emit(&#x27;rollback&#x27;);
    this._unlock();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
};

var proto = Connection.prototype;

proto.close = function(){
    if(this.isDirty()){
        this.<span class="apidocCodeKeywordSpan">rollback</span>();
    }
    for(var name in this.collections){
        this.collections[name].close();
    }
};

consts.collMethods.forEach(function(method){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.document.prototype.update" id="apidoc.element.memdb-server.document.prototype.update">
        function <span class="apidocSignatureSpan">memdb-server.document.prototype.</span>update
        <span class="apidocSignatureSpan">(connId, modifier, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (connId, modifier, opts){
    opts = opts || {};
    if(!modifier){
        throw new Error(&#x27;modifier is empty&#x27;);
    }

    modifier = modifier || {};

    var isModify = false;
    for(var field in modifier){
        isModify = (field[0] === &#x27;$&#x27;);
        break;
    }

    if(!isModify){
        this.modify(connId, &#x27;$replace&#x27;, modifier);
    }
    else{
        for(var cmd in modifier){
            this.modify(connId, cmd, modifier[cmd]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._updateById = function(id, modifier, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">update</span>(self.conn._id, self._key(id), modifier, opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.remove = function(query, opts){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.indexbuilder" id="apidoc.module.memdb-server.indexbuilder">module memdb-server.indexbuilder</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.indexbuilder.drop" id="apidoc.element.memdb-server.indexbuilder.drop">
        function <span class="apidocSignatureSpan">memdb-server.indexbuilder.</span>drop
        <span class="apidocSignatureSpan">(conf, collName, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (conf, collName, keys){
    if(!Array.isArray(keys)){
        keys = keys.split(&#x27; &#x27;);
    }
    var indexKey = JSON.stringify(keys.sort());
    conf.backend.shardId = &#x27;$&#x27;;
    var backend = backends.create(conf.backend);
    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);

    return ensureShutDown(conf.locking)
    .then(function(){
        return backend.start();
    })
    .then(function(){
        return backend.drop(indexCollName);
    })
    .finally(function(){
        logger.warn(&#x27;Droped index %s %s&#x27;, collName, indexKey);
        return backend.stop();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);

    return ensureShutDown(conf.locking)
    .then(function(){
        return backend.start();
    })
    .then(function(){
        return backend.<span class="apidocCodeKeywordSpan">drop</span>(indexCollName);
    })
    .finally(function(){
        logger.warn(&#x27;Droped index %s %s&#x27;, collName, indexKey);
        return backend.stop();
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.indexbuilder.rebuild" id="apidoc.element.memdb-server.indexbuilder.rebuild">
        function <span class="apidocSignatureSpan">memdb-server.indexbuilder.</span>rebuild
        <span class="apidocSignatureSpan">(conf, collName, keys, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rebuild = function (conf, collName, keys, opts){
    opts = opts || {};
    if(!Array.isArray(keys)){
        keys = keys.split(&#x27; &#x27;);
    }
    var indexKey = JSON.stringify(keys.sort());
    conf.backend.shardId = &#x27;$&#x27;;
    var backend = backends.create(conf.backend);

    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);

    logger.warn(&#x27;Start rebuild index %s %s&#x27;, collName, indexKey);

    return ensureShutDown(conf.locking)
    .then(function(){
        return backend.start();
    })
    .then(function(){
        return backend.drop(indexCollName);
    })
    .then(function(){
        return backend.getAll(collName);
    })
    .then(function(itor){
        return utils.mongoForEach(itor, function(item){
            var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);
            if(!indexValue){
                return;
            }

            return P.try(function(){
                return backend.get(indexCollName, indexValue);
            })
            .then(function(doc){
                if(!doc){
                    doc = {_id: indexValue, ids : []};
                }
                else if(opts.unique){
                    throw new Error(&#x27;Duplicate value for unique key &#x27; + indexKey);
                }

                if(doc.ids.indexOf(item._id) === -1){
                    doc.ids.push(item._id);
                }
                return backend.set(indexCollName, indexValue, doc);
            });
        });
    })
    .then(function(){
        logger.warn(&#x27;Finish rebuild index %s %s&#x27;, collName, indexKey);
        return backend.stop();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.modifier" id="apidoc.module.memdb-server.modifier">module memdb-server.modifier</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.mongo_backend" id="apidoc.module.memdb-server.mongo_backend">module memdb-server.mongo_backend</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.mongo_backend" id="apidoc.element.memdb-server.mongo_backend.mongo_backend">
        function <span class="apidocSignatureSpan">memdb-server.</span>mongo_backend
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mongo_backend = function (opts){
    opts = opts || {};

    this.config = {
        url : opts.url || &#x27;mongodb://localhost/test&#x27;,
        options : {server : {socketOptions : {autoReconnect : true}, reconnectTries : 10000000, reconnectInterval : 5000}}, //always
 retry
    };
    this.conn = null;
    this.connected = false;
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.mongo_backend.prototype" id="apidoc.module.memdb-server.mongo_backend.prototype">module memdb-server.mongo_backend.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.drop" id="apidoc.element.memdb-server.mongo_backend.prototype.drop">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>drop
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (name){
    this.ensureConnected();
    this.logger.debug(&#x27;backend mongodb drop %s&#x27;, name);

    if(!!name){
        return this.conn.collection(name).dropAsync()
        .catch(function(e){
            // Ignore ns not found error
            if(e.message.indexOf(&#x27;ns not found&#x27;) === -1){
                throw e;
            }
        });
    }
    else{
        return this.conn.dropDatabaseAsync();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);

    return ensureShutDown(conf.locking)
    .then(function(){
        return backend.start();
    })
    .then(function(){
        return backend.<span class="apidocCodeKeywordSpan">drop</span>(indexCollName);
    })
    .finally(function(){
        logger.warn(&#x27;Droped index %s %s&#x27;, collName, indexKey);
        return backend.stop();
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.ensureConnected" id="apidoc.element.memdb-server.mongo_backend.prototype.ensureConnected">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>ensureConnected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureConnected = function (){
    if(!this.connected){
        throw new Error(&#x27;backend mongodb not connected&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.conn.closeAsync()
    .then(function(){
        self.logger.info(&#x27;backend mongodb closed&#x27;);
    });
};

proto.get = function(name, id){
    this.<span class="apidocCodeKeywordSpan">ensureConnected</span>();
    this.logger.debug(&#x27;backend mongodb get(%s, %s)&#x27;, name, id);

    return this.conn.collection(name).findOneAsync({_id : id});
};

// Return an async iterator with .next(cb) signature
proto.getAll = function(name){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.get" id="apidoc.element.memdb-server.mongo_backend.prototype.get">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>get
        <span class="apidocSignatureSpan">(name, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (name, id){
    this.ensureConnected();
    this.logger.debug(&#x27;backend mongodb get(%s, %s)&#x27;, name, id);

    return this.conn.collection(name).findOneAsync({_id : id});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return utils.mongoForEach(itor, function(item){
var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);
if(!indexValue){
    return;
}

return P.try(function(){
    return backend.<span class="apidocCodeKeywordSpan">get</span>(indexCollName, indexValue);
})
.then(function(doc){
    if(!doc){
        doc = {_id: indexValue, ids : []};
    }
    else if(opts.unique){
        throw new Error(&#x27;Duplicate value for unique key &#x27; + indexKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.getAll" id="apidoc.element.memdb-server.mongo_backend.prototype.getAll">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>getAll
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function (name){
    this.ensureConnected();
    this.logger.debug(&#x27;backend mongodb getAll(%s)&#x27;, name);

    return this.conn.collection(name).findAsync();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function(){
    return backend.start();
})
.then(function(){
    return backend.drop(indexCollName);
})
.then(function(){
    return backend.<span class="apidocCodeKeywordSpan">getAll</span>(collName);
})
.then(function(itor){
    return utils.mongoForEach(itor, function(item){
        var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);
        if(!indexValue){
            return;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.getCollectionNames" id="apidoc.element.memdb-server.mongo_backend.prototype.getCollectionNames">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>getCollectionNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCollectionNames = function (){
    return this.conn.collectionsAsync().then(function(collections){
        return collections.map(function(collection){
            return collection.s.name;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.set" id="apidoc.element.memdb-server.mongo_backend.prototype.set">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>set
        <span class="apidocSignatureSpan">(name, id, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, id, doc){
    this.ensureConnected();
    this.logger.debug(&#x27;backend mongodb set(%s, %s)&#x27;, name, id);

    if(!!doc){
        doc._id = id;
        return this.conn.collection(name).updateAsync({_id : id}, doc, {upsert : true});
    }
    else{
        return this.conn.collection(name).removeAsync({_id : id});
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            else if(opts.unique){
                throw new Error(&#x27;Duplicate value for unique key &#x27; + indexKey);
            }

            if(doc.ids.indexOf(item._id) === -1){
                doc.ids.push(item._id);
            }
            return backend.<span class="apidocCodeKeywordSpan">set</span>(indexCollName, indexValue, doc);
        });
    });
})
.then(function(){
    logger.warn(&#x27;Finish rebuild index %s %s&#x27;, collName, indexKey);
    return backend.stop();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.setMulti" id="apidoc.element.memdb-server.mongo_backend.prototype.setMulti">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>setMulti
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMulti = function (items){
    this.ensureConnected();
    this.logger.debug(&#x27;backend mongodb setMulti&#x27;);

    var self = this;
    return P.mapLimit(items, function(item){
        return self.set(item.name, item.id, item.doc);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return self.slave.set(key, doc);
    }
    else{
        var docs = utils.forceHashMap();
        keys.forEach(function(key){
            docs[key] = self._doc(key)._getChanged();
        });
        return self.slave.<span class="apidocCodeKeywordSpan">setMulti</span>(docs);
    }
    //TODO: possibly loss consistency
    //      if setMulti return failed but actually sccuess
})
.then(function(){
    // Real Commit
    keys.forEach(function(key){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.start" id="apidoc.element.memdb-server.mongo_backend.prototype.start">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (){
    var self = this;

    return P.promisify(mongodb.MongoClient.connect)(this.config.url, this.config.options)
    .then(function(ret){
        self.conn = ret;
        self.connected = true;

        self.conn.on(&#x27;close&#x27;, function(){
            self.connected = false;
            self.logger.error(&#x27;backend mongodb disconnected&#x27;);
        });

        self.conn.on(&#x27;reconnect&#x27;, function(){
            self.connected = true;
            self.logger.warn(&#x27;backend mongodb reconnected&#x27;);
        });

        self.conn.on(&#x27;error&#x27;, function(err){
            self.logger.error(err.stack);
        });

        self.logger.info(&#x27;backend mongodb connected to %s&#x27;, self.config.url);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.mongo_backend.prototype.stop" id="apidoc.element.memdb-server.mongo_backend.prototype.stop">
        function <span class="apidocSignatureSpan">memdb-server.mongo_backend.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (){
    var self = this;

    this.conn.removeAllListeners(&#x27;close&#x27;);

    return this.conn.closeAsync()
    .then(function(){
        self.logger.info(&#x27;backend mongodb closed&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.logger.info(&#x27;database started&#x27;);
    });
};

proto.stop = function(force){
    var self = this;

    this.opsCounter.<span class="apidocCodeKeywordSpan">stop</span>();
    this.tpsCounter.stop();

    return P.try(function(){
// Make sure no new request come anymore

// Wait for all operations finish
return utils.waitUntil(function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.objectid" id="apidoc.module.memdb-server.objectid">module memdb-server.objectid</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.objectid.objectid" id="apidoc.element.memdb-server.objectid.objectid">
        function <span class="apidocSignatureSpan">memdb-server.</span>objectid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  if(!(this instanceof ObjectID)) return new ObjectID(id);
  // Duck-typing to support ObjectId from different npm packages
  if((id instanceof ObjectID) || (id &#x26;&#x26; id.toHexString)) return id;

  this._bsontype = &#x27;ObjectID&#x27;;
  var __id = null;
  var valid = ObjectID.isValid(id);

  // Throw an error if it&#x27;s not a valid setup
  if(!valid &#x26;&#x26; id != null){
    throw new Error(&#x22;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x22;);
  } else if(valid &#x26;&#x26; typeof id == &#x27;string&#x27; &#x26;&#x26; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id == null || typeof id == &#x27;number&#x27;) {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null &#x26;&#x26; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.ObjectID" id="apidoc.element.memdb-server.objectid.ObjectID">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectID
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  if(!(this instanceof ObjectID)) return new ObjectID(id);
  // Duck-typing to support ObjectId from different npm packages
  if((id instanceof ObjectID) || (id &#x26;&#x26; id.toHexString)) return id;

  this._bsontype = &#x27;ObjectID&#x27;;
  var __id = null;
  var valid = ObjectID.isValid(id);

  // Throw an error if it&#x27;s not a valid setup
  if(!valid &#x26;&#x26; id != null){
    throw new Error(&#x22;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x22;);
  } else if(valid &#x26;&#x26; typeof id == &#x27;string&#x27; &#x26;&#x26; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id == null || typeof id == &#x27;number&#x27;) {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null &#x26;&#x26; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.ObjectIDAsync" id="apidoc.element.memdb-server.objectid.ObjectIDAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectIDAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ObjectIDAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;ObjectID&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.ObjectId" id="apidoc.element.memdb-server.objectid.ObjectId">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectId
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectID(id) {
  if(!(this instanceof ObjectID)) return new ObjectID(id);
  // Duck-typing to support ObjectId from different npm packages
  if((id instanceof ObjectID) || (id &#x26;&#x26; id.toHexString)) return id;

  this._bsontype = &#x27;ObjectID&#x27;;
  var __id = null;
  var valid = ObjectID.isValid(id);

  // Throw an error if it&#x27;s not a valid setup
  if(!valid &#x26;&#x26; id != null){
    throw new Error(&#x22;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x22;);
  } else if(valid &#x26;&#x26; typeof id == &#x27;string&#x27; &#x26;&#x26; id.length == 24) {
    return ObjectID.createFromHexString(id);
  } else if(id == null || typeof id == &#x27;number&#x27;) {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null &#x26;&#x26; id.length === 12) {
    // assume 12 byte string
    this.id = id;
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.ObjectIdAsync" id="apidoc.element.memdb-server.objectid.ObjectIdAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>ObjectIdAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ObjectIdAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;ObjectId&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.createFromHexString" id="apidoc.element.memdb-server.objectid.createFromHexString">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromHexString
        <span class="apidocSignatureSpan">(hexString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFromHexString(hexString) {
  // Throw an error if it&#x27;s not a valid setup
  if(typeof hexString === &#x27;undefined&#x27; || hexString != null &#x26;&#x26; hexString.length != 24)
    throw new Error(&#x22;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x22;);

  var len = hexString.length;

  if(len &#x3e; 12*2) {
    throw new Error(&#x27;Id cannot be longer than 12 bytes&#x27;);
  }

  var result = &#x27;&#x27;
    , string
    , number;

  for (var index = 0; index &#x3c; len; index += 2) {
    string = hexString.substr(index, 2);
    number = parseInt(string, 16);
    result += BinaryParser.fromByte(number);
  }

  return new ObjectID(result, hexString);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.createFromHexStringAsync" id="apidoc.element.memdb-server.objectid.createFromHexStringAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromHexStringAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFromHexStringAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;createFromHexString&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.createFromTime" id="apidoc.element.memdb-server.objectid.createFromTime">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromTime
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFromTime(time) {
  var id = BinaryParser.encodeInt(time, 32, true, true) +
           BinaryParser.encodeInt(0, 64, true, true);
  return new ObjectID(id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.createFromTimeAsync" id="apidoc.element.memdb-server.objectid.createFromTimeAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createFromTimeAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFromTimeAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;createFromTime&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.createPk" id="apidoc.element.memdb-server.objectid.createPk">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createPk
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPk() {
  return new ObjectID();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.createPkAsync" id="apidoc.element.memdb-server.objectid.createPkAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>createPkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createPkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;createPk&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.isValid" id="apidoc.element.memdb-server.objectid.isValid">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>isValid
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isValid(id) {
  if(id == null) return false;

  if(typeof id == &#x27;number&#x27;)
    return true;
  if(typeof id == &#x27;string&#x27;) {
    return id.length == 12 || (id.length == 24 &#x26;&#x26; checkForHexRegExp.test(id));
  }
  if(id instanceof ObjectID) {
    return true;
  }
  // Duck-Typing detection of ObjectId like objects
  if(id.toHexString) {
    return id.id.length == 12 || (id.id.length == 24 &#x26;&#x26; checkForHexRegExp.test(id.id));
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.isValidAsync" id="apidoc.element.memdb-server.objectid.isValidAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.</span>isValidAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isValidAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;isValid&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.objectid.prototype" id="apidoc.module.memdb-server.objectid.prototype">module memdb-server.objectid.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.equals" id="apidoc.element.memdb-server.objectid.prototype.equals">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>equals
        <span class="apidocSignatureSpan">(otherID)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(otherID) {
  var id;

  if(otherID != null &#x26;&#x26; (otherID instanceof ObjectID || otherID.toHexString)) {
    id = otherID.id;
  } else if(typeof otherID == &#x27;string&#x27; &#x26;&#x26; ObjectID.isValid(otherID)) {
    id = ObjectID.createFromHexString(otherID).id;
  } else {
    return false;
  }

  return this.id === id;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.equalsAsync" id="apidoc.element.memdb-server.objectid.prototype.equalsAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>equalsAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equalsAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;equals&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.generate" id="apidoc.element.memdb-server.objectid.prototype.generate">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>generate
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (time) {
  if (&#x27;number&#x27; != typeof time) {
    time = parseInt(Date.now()/1000,10);
  }

  var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);
<span class="apidocCodeCommentSpan">  /* for time-based ObjectID the bytes following the time will be zeroed */
</span>  var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
  var pid2Bytes = BinaryParser.fromShort((typeof process === &#x27;undefined&#x27; ? Math.floor(Math.random() * 100000) : process.pid) % 0xFFFF
);
  var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);

  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.generateAsync" id="apidoc.element.memdb-server.objectid.prototype.generateAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>generateAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generateAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;generate&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.getInc" id="apidoc.element.memdb-server.objectid.prototype.getInc">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getInc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getInc = function () {
  return this.get_inc();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.getIncAsync" id="apidoc.element.memdb-server.objectid.prototype.getIncAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getIncAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIncAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;getInc&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.getTimestamp" id="apidoc.element.memdb-server.objectid.prototype.getTimestamp">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getTimestamp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTimestamp = function () {
  var timestamp = new Date();
  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true)) * 1000);
  return timestamp;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.getTimestampAsync" id="apidoc.element.memdb-server.objectid.prototype.getTimestampAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>getTimestampAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTimestampAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;getTimestamp&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.get_inc" id="apidoc.element.memdb-server.objectid.prototype.get_inc">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>get_inc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_inc = function () {
  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.get_incAsync" id="apidoc.element.memdb-server.objectid.prototype.get_incAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>get_incAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_incAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;get_inc&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.inspect" id="apidoc.element.memdb-server.objectid.prototype.inspect">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>inspect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function () {
  return this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.inspectAsync" id="apidoc.element.memdb-server.objectid.prototype.inspectAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>inspectAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspectAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;inspect&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.toHexString" id="apidoc.element.memdb-server.objectid.prototype.toHexString">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toHexString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHexString = function () {
  if(ObjectID.cacheHexString &#x26;&#x26; this.__id) return this.__id;

  var hexString = &#x27;&#x27;;

  for (var i = 0; i &#x3c; this.id.length; i++) {
    hexString += hexTable[this.id.charCodeAt(i)];
  }

  if(ObjectID.cacheHexString) this.__id = hexString;
  return hexString;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.toHexStringAsync" id="apidoc.element.memdb-server.objectid.prototype.toHexStringAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toHexStringAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHexStringAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;toHexString&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.toJSON" id="apidoc.element.memdb-server.objectid.prototype.toJSON">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  return this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.toJSONAsync" id="apidoc.element.memdb-server.objectid.prototype.toJSONAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toJSONAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSONAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;toJSON&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.toString" id="apidoc.element.memdb-server.objectid.prototype.toString">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return this.toHexString();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._checkId = function(id){
if(typeof(id) === &#x27;string&#x27;){
    return id;
}
else if(typeof(id) === &#x27;number&#x27;){
    return id.<span class="apidocCodeKeywordSpan">toString</span>();
}
throw new Error(&#x27;id must be number or string&#x27;);
};

//http://docs.mongodb.org/manual/reference/limits/#Restriction-on-Collection-Names
proto._checkName = function(name){
if(!name){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.objectid.prototype.toStringAsync" id="apidoc.element.memdb-server.objectid.prototype.toStringAsync">
        function <span class="apidocSignatureSpan">memdb-server.objectid.prototype.</span>toStringAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toStringAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise);
    var ret;
    var callback = tryCatch(this != null ? this[&#x27;toString&#x27;] : fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.protocol" id="apidoc.module.memdb-server.protocol">module memdb-server.protocol</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.protocol.protocol" id="apidoc.element.memdb-server.protocol.protocol">
        function <span class="apidocSignatureSpan">memdb-server.</span>protocol
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">protocol = function (opts){
    EventEmitter.call(this);

    opts = opts || {};

    this.socket = opts.socket;
    this.socket.setEncoding(&#x27;utf8&#x27;);

    this.maxMsgLength = opts.maxMsgLength || DEFAULT_MAX_MSG_LENGTH;

    this.remainLine = &#x27;&#x27;;

    var self = this;
    this.socket.on(&#x27;data&#x27;, function(data){
        // message is json encoded and splited by &#x27;\n&#x27;
        var lines = data.split(&#x27;\n&#x27;);
        for(var i=0; i&#x3c;lines.length - 1; i++){
            try{
                var msg = &#x27;&#x27;;
                if(i === 0){
                    msg = JSON.parse(self.remainLine + lines[i]);
                    self.remainLine = &#x27;&#x27;;
                }
                else{
                    msg = JSON.parse(lines[i]);
                }
                self.emit(&#x27;msg&#x27;, msg);
            }
            catch(err){
                logger.error(err.stack);
            }
        }
        self.remainLine = lines[lines.length - 1];
    });

    this.socket.on(&#x27;close&#x27;, function(hadError){
        self.emit(&#x27;close&#x27;, hadError);
    });

    this.socket.on(&#x27;connect&#x27;, function(){
        self.emit(&#x27;connect&#x27;);
    });

    this.socket.on(&#x27;error&#x27;, function(err){
        self.emit(&#x27;error&#x27;, err);
    });

    this.socket.on(&#x27;timeout&#x27;, function(){
        self.emit(&#x27;timeout&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.protocol.super_" id="apidoc.element.memdb-server.protocol.super_">
        function <span class="apidocSignatureSpan">memdb-server.protocol.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.protocol.prototype" id="apidoc.module.memdb-server.protocol.prototype">module memdb-server.protocol.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.protocol.prototype.disconnect" id="apidoc.element.memdb-server.protocol.prototype.disconnect">
        function <span class="apidocSignatureSpan">memdb-server.protocol.prototype.</span>disconnect
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">disconnect = function (){
    this.socket.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            connId : connId,
        };
    }
    if(!msg.connId){
        throw new Error(&#x27;connId is required&#x27;);
    }
    if(msg.method === &#x27;disconnect&#x27;){
        return db.<span class="apidocCodeKeywordSpan">disconnect</span>(msg.connId)
        .then(function(){
            delete connIds[msg.connId];
        });
    }
    return db.execute(msg.connId, msg.method, msg.args);
})
.then(function(ret){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.protocol.prototype.send" id="apidoc.element.memdb-server.protocol.prototype.send">
        function <span class="apidocSignatureSpan">memdb-server.protocol.prototype.</span>send
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">send = function (msg){
    var data = JSON.stringify(msg) + &#x27;\n&#x27;;
    if(data.length &#x3e; this.maxMsgLength){
        throw new Error(&#x27;msg length exceed limit&#x27;);
    }

    var ret = this.socket.write(data);
    if(!ret){
        logger.warn(&#x27;socket.write return false&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        resp.err = {
            message : err.message,
            stack : err.stack,
        };
        resp.data = null;
    })
    .then(function(){
        protocol.<span class="apidocCodeKeywordSpan">send</span>(resp);
        logger.debug(&#x27;[conn:%s] %s &#x3c;= %j&#x27;, msg.connId, remoteAddress, resp);
    })
    .catch(function(e){
        logger.error(e.stack);
    });
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.redis_backend" id="apidoc.module.memdb-server.redis_backend">module memdb-server.redis_backend</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.redis_backend" id="apidoc.element.memdb-server.redis_backend.redis_backend">
        function <span class="apidocSignatureSpan">memdb-server.</span>redis_backend
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redis_backend = function (opts){
    opts = opts || {};

    this.config = {
        host : opts.host || &#x27;127.0.0.1&#x27;,
        port : opts.port || 6379,
        db : opts.db || 0,
        options : opts.option || {},
        prefix : opts.prefix || &#x27;&#x27;,
    };
    this.conn = null;

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.redis_backend.prototype" id="apidoc.module.memdb-server.redis_backend.prototype">module memdb-server.redis_backend.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.drop" id="apidoc.element.memdb-server.redis_backend.prototype.drop">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>drop
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drop = function (name){
    this.logger.debug(&#x27;backend redis drop %s&#x27;, name);

    if(!!name){
        throw new Error(&#x27;not implemented&#x27;);
        //this.conn.delAsync(this.config.prefix + name);
    }
    else{
        this.conn.flushdbAsync();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var indexCollName = Collection.prototype._indexCollectionName.call({name : collName}, indexKey);

    return ensureShutDown(conf.locking)
    .then(function(){
        return backend.start();
    })
    .then(function(){
        return backend.<span class="apidocCodeKeywordSpan">drop</span>(indexCollName);
    })
    .finally(function(){
        logger.warn(&#x27;Droped index %s %s&#x27;, collName, indexKey);
        return backend.stop();
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.get" id="apidoc.element.memdb-server.redis_backend.prototype.get">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>get
        <span class="apidocSignatureSpan">(name, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (name, id){
    this.logger.debug(&#x27;backend redis get(%s, %s)&#x27;, name, id);

    return P.bind(this)
    .then(function(){
        return this.conn.hmgetAsync(this.config.prefix + name, id);
    })
    .then(function(ret){
        ret = ret[0];
        return JSON.parse(ret);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return utils.mongoForEach(itor, function(item){
var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);
if(!indexValue){
    return;
}

return P.try(function(){
    return backend.<span class="apidocCodeKeywordSpan">get</span>(indexCollName, indexValue);
})
.then(function(doc){
    if(!doc){
        doc = {_id: indexValue, ids : []};
    }
    else if(opts.unique){
        throw new Error(&#x27;Duplicate value for unique key &#x27; + indexKey);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.getAll" id="apidoc.element.memdb-server.redis_backend.prototype.getAll">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>getAll
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAll = function (name){
    throw new Error(&#x27;not implemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function(){
    return backend.start();
})
.then(function(){
    return backend.drop(indexCollName);
})
.then(function(){
    return backend.<span class="apidocCodeKeywordSpan">getAll</span>(collName);
})
.then(function(itor){
    return utils.mongoForEach(itor, function(item){
        var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);
        if(!indexValue){
            return;
        }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.getCollectionNames" id="apidoc.element.memdb-server.redis_backend.prototype.getCollectionNames">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>getCollectionNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getCollectionNames = function (){
    throw new Error(&#x27;not implemented&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.set" id="apidoc.element.memdb-server.redis_backend.prototype.set">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>set
        <span class="apidocSignatureSpan">(name, id, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (name, id, doc){
    this.logger.debug(&#x27;backend redis set(%s, %s)&#x27;, name, id);

    if(!!doc){
        return this.conn.hmsetAsync(this.config.prefix + name, id, JSON.stringify(doc));
    }
    else{
        return this.conn.hdelAsync(this.config.prefix + name, id);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            else if(opts.unique){
                throw new Error(&#x27;Duplicate value for unique key &#x27; + indexKey);
            }

            if(doc.ids.indexOf(item._id) === -1){
                doc.ids.push(item._id);
            }
            return backend.<span class="apidocCodeKeywordSpan">set</span>(indexCollName, indexValue, doc);
        });
    });
})
.then(function(){
    logger.warn(&#x27;Finish rebuild index %s %s&#x27;, collName, indexKey);
    return backend.stop();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.setMulti" id="apidoc.element.memdb-server.redis_backend.prototype.setMulti">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>setMulti
        <span class="apidocSignatureSpan">(items)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMulti = function (items){
    this.logger.debug(&#x27;backend redis setMulti&#x27;);

    var multi = this.conn.multi();

    var self = this;
    items.forEach(function(item){
        if(!!item.doc){
            multi = multi.hmset(self.config.prefix + item.name, item.id, JSON.stringify(item.doc));
        }
        else{
            multi = multi.hdel(self.config.prefix + item.name, item.id);
        }
    });
    return multi.execAsync();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return self.slave.set(key, doc);
    }
    else{
        var docs = utils.forceHashMap();
        keys.forEach(function(key){
            docs[key] = self._doc(key)._getChanged();
        });
        return self.slave.<span class="apidocCodeKeywordSpan">setMulti</span>(docs);
    }
    //TODO: possibly loss consistency
    //      if setMulti return failed but actually sccuess
})
.then(function(){
    // Real Commit
    keys.forEach(function(key){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.start" id="apidoc.element.memdb-server.redis_backend.prototype.start">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (){
    this.conn = redis.createClient(this.config.port, this.config.host, {retry_max_delay : 10 * 1000});

    var self = this;
    this.conn.on(&#x27;error&#x27;, function(err){
        self.logger.error(err.stack);
    });

    this.conn.select(this.config.db);

    this.logger.debug(&#x27;backend redis connected to %s:%s:%s&#x27;, this.config.host, this.config.port, this.config.db);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.redis_backend.prototype.stop" id="apidoc.element.memdb-server.redis_backend.prototype.stop">
        function <span class="apidocSignatureSpan">memdb-server.redis_backend.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (){
    this.logger.debug(&#x27;backend redis stop&#x27;);
    return this.conn.quitAsync();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.logger.info(&#x27;database started&#x27;);
    });
};

proto.stop = function(force){
    var self = this;

    this.opsCounter.<span class="apidocCodeKeywordSpan">stop</span>();
    this.tpsCounter.stop();

    return P.try(function(){
// Make sure no new request come anymore

// Wait for all operations finish
return utils.waitUntil(function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.server" id="apidoc.module.memdb-server.server">module memdb-server.server</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.server.start" id="apidoc.element.memdb-server.server.start">
        function <span class="apidocSignatureSpan">memdb-server.server.</span>start
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (opts){
    var deferred = P.defer();

    var logger = memdbLogger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);
    logger.warn(&#x27;starting %s...&#x27;, opts.shardId);

    var bind = opts.bind || &#x27;0.0.0.0&#x27;;
    var port = opts.port || DEFAULT_PORT;

    var db = new Database(opts);

    var sockets = utils.forceHashMap();

    var _isShutingDown = false;

    var server = net.createServer(function(socket){

        var clientId = uuid.v4();
        sockets[clientId] = socket;

        var connIds = utils.forceHashMap();
        var remoteAddress = socket.remoteAddress;
        var protocol = new Protocol({socket : socket});

        protocol.on(&#x27;msg&#x27;, function(msg){
            logger.debug(&#x27;[conn:%s] %s =&#x3e; %j&#x27;, msg.connId, remoteAddress, msg);
            var resp = {seq : msg.seq};

            P.try(function(){
                if(msg.method === &#x27;connect&#x27;){
                    var clientVersion = msg.args[0];
                    if(parseFloat(clientVersion) &#x3c; parseFloat(consts.minClientVersion)){
                        throw new Error(&#x27;client version not supported, please upgrade&#x27;);
                    }
                    var connId = db.connect().connId;
                    connIds[connId] = true;
                    return {
                        connId : connId,
                    };
                }
                if(!msg.connId){
                    throw new Error(&#x27;connId is required&#x27;);
                }
                if(msg.method === &#x27;disconnect&#x27;){
                    return db.disconnect(msg.connId)
                    .then(function(){
                        delete connIds[msg.connId];
                    });
                }
                return db.execute(msg.connId, msg.method, msg.args);
            })
            .then(function(ret){
                resp.err = null;
                resp.data = ret;
            }, function(err){
                resp.err = {
                    message : err.message,
                    stack : err.stack,
                };
                resp.data = null;
            })
            .then(function(){
                protocol.send(resp);
                logger.debug(&#x27;[conn:%s] %s &#x3c;= %j&#x27;, msg.connId, remoteAddress, resp);
            })
            .catch(function(e){
                logger.error(e.stack);
            });
        });

        protocol.on(&#x27;close&#x27;, function(){
            P.map(Object.keys(connIds), function(connId){
                return db.disconnect(connId);
            })
            .then(function(){
                connIds = utils.forceHashMap();
                delete sockets[clientId];
                logger.info(&#x27;client %s disconnected&#x27;, remoteAddress);
            })
            .catch(function(e){
                logger.error(e.stack);
            });
        });

        protocol.on(&#x27;error&#x27;, function(e){
            logger.error(e.stack);
        });

        logger.info(&#x27;client %s connected&#x27;, remoteAddress);
    });

    server.on(&#x27;error&#x27;, function(err){
        logger.error(err.stack);

        if(!deferred.isResolved()){
            deferred.reject(err);
        }
    });

    P.try(function(){
        return P.promisify(server.listen, server)(port, bind);
    })
    .then(function(){
        return db.start();
    })
    .then(function(){
        logger.warn(&#x27;server started on %s:%s&#x27;, bind, port);
        deferred.resolve();
    })
    .catch(function(err){
        logger.error(err.stack);
        deferred.reject(err);
    });

    var shutdown = function(){
        logger.warn(&#x27;receive shutdown signal&#x27;);

        if(_isShutingDown){
            return;
        }
        _isShutingDown = true;

        return P.try(function(){
            var deferred = P.defer();

            server.once(&#x27;close&#x27;, function(){
                logger.debug(&#x27;on server close&#x27;);
                deferred.resolve();
            });

            server.close();

            Object.keys(sockets).forEach(function(id){
                try{
                    sockets[id].end();
                    sockets[id].destroy();
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.shard" id="apidoc.module.memdb-server.shard">module memdb-server.shard</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.shard.shard" id="apidoc.element.memdb-server.shard.shard">
        function <span class="apidocSignatureSpan">memdb-server.</span>shard
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shard = function (opts){
    EventEmitter.call(this);

    opts = opts || {};

    this._id = opts.shardId;
    if(!this._id){
        throw new Error(&#x27;shardId is empty&#x27;);
    }
    this._id = this._id.toString();
    if(this._id.indexOf(&#x27;$&#x27;) !== -1){
        throw new Error(&#x27;shardId can not contain &#x22;$&#x22;&#x27;);
    }

    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this._id);

    this.config = {
        locking : opts.locking || {},
        backend : opts.backend || {},
        slave : opts.slave || {},

        shards : opts.shards || {},

        idleTimeout : opts.hasOwnProperty(&#x27;idleTimeout&#x27;) ? opts.idleTimeout : DEFAULT_IDLE_TIMEOUT,
        persistentDelay : opts.hasOwnProperty(&#x27;persistentDelay&#x27;) ?  opts.persistentDelay : DEFAULT_PERSISTENT_DELAY,

        heartbeatInterval : opts.heartbeatInterval || DEFAULT_HEARTBEAT_INTERVAL,
        heartbeatTimeout : opts.heartbeatTimeout || DEFAULT_HEARTBEAT_TIMEOUT,
        backendLockTimeout : opts.backendLockTimeout || DEFAULT_BACKEND_LOCK_TIMEOUT,
        backendLockRetryInterval : opts.backendLockRetryInterval || DEFAULT_BACKEND_LOCK_RETRY_INTERVAL,
        reloadDelay : opts.reloadDelay || DEFAULT_RELOAD_DELAY,
        lockTimeout : opts.lockTimeout || DEFAULT_LOCK_TIMEOUT,

        memoryLimit : opts.memoryLimit || DEFAULT_MEMORY_LIMIT,
        gcCount : opts.gcCount || DEFAULT_GC_COUNT,
        gcInterval : opts.gcInterval || DEFAULT_GC_INTERVAL,

        disableSlave : opts.disableSlave || false,

        collections : opts.collections || {},
    };

    // global locking
    var lockerConf = this.config.locking;
    lockerConf.shardId = this._id;
    lockerConf.heartbeatTimeout = this.config.heartbeatTimeout;
    lockerConf.heartbeatInterval = this.config.heartbeatInterval;
    this.backendLocker = new BackendLocker(lockerConf);

    // backend storage
    var backendConf = this.config.backend;
    backendConf.shardId = this._id;
    this.backend = backends.create(backendConf);

    // slave redis
    var slaveConf = this.config.slave;
    slaveConf.shardId = this._id;
    this.slave = new Slave(slaveConf);

    // memdb client to communicate with other shards
    this.autoconn = new AutoConnection({
        shards : this.config.shards,
        concurrentInConnection : true,
    });

    // Document storage {key : doc}
    this.docs = utils.forceHashMap();

    // Newly commited docs (for incremental _save)
    this.commitedKeys = utils.forceHashMap(); // {key : version}

    // Idle timeout before unload
    this.idleTimeouts = utils.forceHashMap(); // {key : timeout}

    // Doc persistent timeout
    this.persistentTimeouts = utils.forceHashMap(); // {key : timeout}

    // GC interval
    this.gcInterval = null;

    // Lock async operations for each key
    this.keyLock = new AsyncLock({Promise : P});

    // Task locker
    this.taskLock = new AsyncLock({Promise : P});

    // Doc locker
    this.docLock = new AsyncLock({
        timeout : this.config.lockTimeout,
        Promise : P,
    });

    // Current concurrent commiting processes
    this.commitingCount = 0;

    // Current key unloading task
    this.unloadingKeys = utils.forceHashMap();

    this.loadCounter = utils.rateCounter();
    this.unloadCounter = utils.rateCounter();
    this.persistentCounter = utils.rateCounter();

    this.state = STATE.INITED;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.super_" id="apidoc.element.memdb-server.shard.super_">
        function <span class="apidocSignatureSpan">memdb-server.shard.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.shard.prototype" id="apidoc.module.memdb-server.shard.prototype">module memdb-server.shard.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._addDoc" id="apidoc.element.memdb-server.shard.prototype._addDoc">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_addDoc
        <span class="apidocSignatureSpan">(key, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_addDoc = function (key, obj){
    var self = this;

    var res = this._resolveKey(key);
    var coll = this.config.collections[res.name];
    var indexes = (coll &#x26;&#x26; coll.indexes) || {};

    var opts = {
        _id : res.id,
        doc: obj,
        indexes: indexes,
        locker : this.docLock,
        lockKey : key,
    };
    var doc = new Document(opts);

    this._startIdleTimeout(key);

    doc.on(&#x27;lock&#x27;, function(){
        self._cancelIdleTimeout(key);
    });

    doc.on(&#x27;unlock&#x27;, function(){
        self._startIdleTimeout(key);
    });

    doc.on(&#x27;commit&#x27;, function(){
        self._setCommited(key);

        // delay sometime and persistent to backend
        if(!self.persistentTimeouts.hasOwnProperty(key) &#x26;&#x26; self.config.persistentDelay &#x3e;= 0){
            self.persistentTimeouts[key] = setTimeout(function(){
                delete self.persistentTimeouts[key];
                return self.keyLock.acquire(key, function(){
                    return self._persistent(key);
                })
                .catch(function(err){
                    self.logger.error(err.stack);
                });
            }, self.config.persistentDelay);
        }
    });

    doc.on(&#x27;updateIndex&#x27;, function(connId, indexKey, oldValue, newValue){
        // pass event to collection
        self.emit(&#x27;updateIndex$&#x27; + res.name + &#x27;$&#x27; + connId, res.id, indexKey, oldValue, newValue);
    });

    // Loaded at this instant
    self.docs[key] = doc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        obj = ret;
        if(!self.config.disableSlave){
            // Sync data to slave
            return self.slave.set(key, obj);
        }
    })
    .then(function(){
        self.<span class="apidocCodeKeywordSpan">_addDoc</span>(key, obj);

        self.loadCounter.inc();
        self.logger.info(&#x27;loaded %s&#x27;, key);
    });
};

proto._addDoc = function(key, obj){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._cancelIdleTimeout" id="apidoc.element.memdb-server.shard.prototype._cancelIdleTimeout">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_cancelIdleTimeout
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_cancelIdleTimeout = function (key){
    clearTimeout(this.idleTimeouts[key]);
    delete this.idleTimeouts[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.find = function(connId, key, fields){
this._ensureState(STATE.RUNNING);
var self = this;

if(this.docs[key]){ //already loaded
    if(this.docs[key].isFree()){
        // restart idle timer if doc doesn&#x27;t locked by anyone
        this.<span class="apidocCodeKeywordSpan">_cancelIdleTimeout</span>(key);
        this._startIdleTimeout(key);
    }

    var ret = this.docs[key].find(connId, fields);
    self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
    return ret;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._doc" id="apidoc.element.memdb-server.shard.prototype._doc">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_doc
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_doc = function (key){
    if(!this.docs.hasOwnProperty(key)){
        throw new Error(key + &#x27; is not loaded&#x27;);
    }
    return this.docs[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
};

proto.update = function(connId, key, doc, opts){
this._ensureState(STATE.RUNNING);

// Since lock is called before, so doc is loaded for sure
var ret = this.<span class="apidocCodeKeywordSpan">_doc</span>(key).update(connId, doc, opts);

this.logger.debug(&#x27;[conn:%s] update(%s, %j, %j) =&#x3e; %s&#x27;, connId, key, doc, opts, ret);
return ret;
};

proto.insert = function(connId, key, doc){
this._ensureState(STATE.RUNNING);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._ensureState" id="apidoc.element.memdb-server.shard.prototype._ensureState">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_ensureState
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_ensureState = function (state){
    if(this.state !== state){
        throw new Error(util.format(&#x27;Server state is incorrect, expected %s, actual %s&#x27;, state, this.state));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

util.inherits(Shard, EventEmitter);

var proto = Shard.prototype;

proto.start = function(){
this.<span class="apidocCodeKeywordSpan">_ensureState</span>(STATE.INITED);
this.state = STATE.STARTING;

return P.bind(this)
.then(function(){
    return this.backendLocker.start();
})
.then(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._isLoaded" id="apidoc.element.memdb-server.shard.prototype._isLoaded">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_isLoaded
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isLoaded = function (key){
    return !!this.docs[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.docs[key] &#x26;&#x26; this.docs[key].isLocked(connId);
};

proto.findReadOnly = function(connId, key, fields){
this._ensureState(STATE.RUNNING);
var self = this;

if(this.<span class="apidocCodeKeywordSpan">_isLoaded</span>(key)){
    return this.find(connId, key, fields);
}
return P.try(function(){
    return self.backendLocker.getHolderId(key);
})
.then(function(shardId){
    if(!shardId || shardId === self._id){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._load" id="apidoc.element.memdb-server.shard.prototype._load">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_load
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_load = function (key){
    if(this.docs[key]){ // already loaded
        return;
    }

    this.logger.debug(&#x27;start load %s&#x27;, key);

    var obj = null;

    var self = this;
    return P.try(function(){
        // get backend lock
        return self._lockBackend(key);
    })
    .then(function(){
        var res = self._resolveKey(key);

        return self.backend.get(res.name, res.id);
    })
    .then(function(ret){
        obj = ret;
        if(!self.config.disableSlave){
            // Sync data to slave
            return self.slave.set(key, obj);
        }
    })
    .then(function(){
        self._addDoc(key, obj);

        self.loadCounter.inc();
        self.logger.info(&#x27;loaded %s&#x27;, key);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var ret = this.docs[key].find(connId, fields);
    self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
    return ret;
}

return this.keyLock.acquire(key, function(){
    return P.try(function(){
        return self.<span class="apidocCodeKeywordSpan">_load</span>(key);
    })
    .then(function(){
        return self.docs[key].find(connId, fields);
    })
    .then(function(ret){
        self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
        return ret;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._lockBackend" id="apidoc.element.memdb-server.shard.prototype._lockBackend">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_lockBackend
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_lockBackend = function (key){
    var self = this;
    return P.try(function(){
        return self.backendLocker.tryLock(key);
    })
    .then(function(success){
        if(success){
            return;
        }

        var startTick = Date.now();

        var tryLock = function(wait){
            return P.try(function(){
                return self.backendLocker.getHolderId(key);
            })
            .then(function(shardId){
                if(shardId === self._id){
                    // already locked
                    return;
                }

                return P.try(function(){
                    if(shardId){
                        // notify holder to unload the doc
                        return self.autoconn.$unload(shardId, key);
                    }
                    else{
                        return true;
                    }
                })
                .then(function(success){
                    if(success){
                        return self.backendLocker.tryLock(key);
                    }
                    else{
                        return false;
                    }
                })
                .then(function(success){
                    if(success){
                        self.logger.debug(&#x27;locked backend doc - %s (%sms)&#x27;, key, Date.now() - startTick);
                        return;
                    }

                    if(Date.now() - startTick &#x3e;= self.config.backendLockTimeout){
                        throw new Error(&#x27;lock backend doc - &#x27; + key + &#x27; timed out&#x27;);
                    }

                    // delay some time and try again
                    return P.delay(wait / 2 + _.random(wait))
                    .then(function(){
                        return tryLock(wait);
                    });
                });
            });
        };

        return tryLock(self.config.backendLockRetryInterval);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.logger.debug(&#x27;start load %s&#x27;, key);

var obj = null;

var self = this;
return P.try(function(){
    // get backend lock
    return self.<span class="apidocCodeKeywordSpan">_lockBackend</span>(key);
})
.then(function(){
    var res = self._resolveKey(key);

    return self.backend.get(res.name, res.id);
})
.then(function(ret){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._persistent" id="apidoc.element.memdb-server.shard.prototype._persistent">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_persistent
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_persistent = function (key){
    if(!this.commitedKeys.hasOwnProperty(key)){
        return; // no change
    }

    var doc = this._doc(key)._getCommited();
    var ver = this.commitedKeys[key]; // get current version

    var self = this;
    var res = this._resolveKey(key);

    return this.backend.set(res.name, res.id, doc)
    .then(function(){
        // no new change, remove the flag
        if(self.commitedKeys[key] === ver){
            delete self.commitedKeys[key];
        }

        self.persistentCounter.inc();
        self.logger.debug(&#x27;persistented %s&#x27;, key);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    self._setCommited(key);

    // delay sometime and persistent to backend
    if(!self.persistentTimeouts.hasOwnProperty(key) &#x26;&#x26; self.config.persistentDelay &#x3e;= 0){
        self.persistentTimeouts[key] = setTimeout(function(){
            delete self.persistentTimeouts[key];
            return self.keyLock.acquire(key, function(){
                return self.<span class="apidocCodeKeywordSpan">_persistent</span>(key);
            })
            .catch(function(err){
                self.logger.error(err.stack);
            });
        }, self.config.persistentDelay);
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._resolveKey" id="apidoc.element.memdb-server.shard.prototype._resolveKey">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_resolveKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_resolveKey = function (key){
    var i = key.indexOf(&#x27;$&#x27;);
    if(i === -1){
        throw new Error(&#x27;invalid key: &#x27; + key);
    }
    return {name : key.slice(0, i), id : key.slice(i + 1)};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var self = this;
return P.try(function(){
    // get backend lock
    return self._lockBackend(key);
})
.then(function(){
    var res = self.<span class="apidocCodeKeywordSpan">_resolveKey</span>(key);

    return self.backend.get(res.name, res.id);
})
.then(function(ret){
    obj = ret;
    if(!self.config.disableSlave){
        // Sync data to slave
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._setCommited" id="apidoc.element.memdb-server.shard.prototype._setCommited">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_setCommited
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_setCommited = function (key){
    if(!this.commitedKeys.hasOwnProperty(key)){
        this.commitedKeys[key] = 0;
    }
    this.commitedKeys[key]++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    doc.on(&#x27;unlock&#x27;, function(){
self._startIdleTimeout(key);
    });

    doc.on(&#x27;commit&#x27;, function(){
self.<span class="apidocCodeKeywordSpan">_setCommited</span>(key);

// delay sometime and persistent to backend
if(!self.persistentTimeouts.hasOwnProperty(key) &#x26;&#x26; self.config.persistentDelay &#x3e;= 0){
    self.persistentTimeouts[key] = setTimeout(function(){
        delete self.persistentTimeouts[key];
        return self.keyLock.acquire(key, function(){
            return self._persistent(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._startIdleTimeout" id="apidoc.element.memdb-server.shard.prototype._startIdleTimeout">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_startIdleTimeout
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_startIdleTimeout = function (key){
    if(!this.config.idleTimeout){
        return;
    }

    var self = this;
    this.idleTimeouts[key] = setTimeout(function(){
        return self.keyLock.acquire(key, function(){
            if(self.docs[key]){
                self.logger.debug(&#x27;%s idle timed out, will unload&#x27;, key);
                return self._unload(key);
            }
        })
        .catch(function(e){
            self.logger.error(e.stack);
        });
    }, this.config.idleTimeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this._ensureState(STATE.RUNNING);
var self = this;

if(this.docs[key]){ //already loaded
    if(this.docs[key].isFree()){
        // restart idle timer if doc doesn&#x27;t locked by anyone
        this._cancelIdleTimeout(key);
        this.<span class="apidocCodeKeywordSpan">_startIdleTimeout</span>(key);
    }

    var ret = this.docs[key].find(connId, fields);
    self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
    return ret;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._unload" id="apidoc.element.memdb-server.shard.prototype._unload">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_unload
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unload = function (key){
    if(!this.docs[key]){ //already unloaded
        return;
    }

    this.logger.debug(&#x27;start unload %s&#x27;, key);

    var doc = this.docs[key];

    return P.bind(this)
    .then(function(){
        // Wait all existing lock release
        return doc._waitUnlock();
    })
    .then(function(){
        // Persistent immediately
        return this._persistent(key);
    })
    .then(function(){
        if(!this.config.disableSlave){
            // sync data to slave
            return this.slave.del(key);
        }
    })
    .then(function(){
        this._cancelIdleTimeout(key);

        if(this.persistentTimeouts.hasOwnProperty(key)){
            clearTimeout(this.persistentTimeouts[key]);
            delete this.persistentTimeouts[key];
        }

        doc.removeAllListeners(&#x27;commit&#x27;);
        doc.removeAllListeners(&#x27;updateIndex&#x27;);
        doc.removeAllListeners(&#x27;lock&#x27;);
        doc.removeAllListeners(&#x27;unlock&#x27;);

        // _unloaded at this instant
        delete this.docs[key];

        // Release backend lock
        return this._unlockBackend(key);
    })
    .then(function(){
        this.unloadCounter.inc();

        this.logger.info(&#x27;unloaded %s&#x27;, key);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function(){
    this.logger.debug(&#x27;all commit processes finished&#x27;);
    // WARN: Make sure all connections are closed now

    var self = this;
    return P.mapLimit(Object.keys(this.docs), function(key){
        return self.keyLock.acquire(key, function(){
            return self.<span class="apidocCodeKeywordSpan">_unload</span>(key);
        })
        .catch(function(e){
            self.logger.error(e.stack);
        });
    });
})
.then(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype._unlockBackend" id="apidoc.element.memdb-server.shard.prototype._unlockBackend">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>_unlockBackend
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_unlockBackend = function (key){
    return this.backendLocker.unlock(key);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// or a redundant backend lock is held caused by unsuccessful unload
self.logger.warn(&#x27;this shard does not hold %s&#x27;, key);

return P.try(function(){
    return self.slave.del(key);
})
.then(function(){
    return self.<span class="apidocCodeKeywordSpan">_unlockBackend</span>(key);
})
.then(function(){
    deferred.resolve(true);
}, function(e){
    deferred.reject(e);
    throw e;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.commit" id="apidoc.element.memdb-server.shard.prototype.commit">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>commit
        <span class="apidocSignatureSpan">(connId, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commit = function (connId, keys){
    this._ensureState(STATE.RUNNING);

    if(!Array.isArray(keys)){
        keys = [keys];
    }
    if(keys.length === 0){
        return;
    }

    var self = this;

    keys.forEach(function(key){
        if(!self.isLocked(connId, key)){
            throw new Error(&#x27;[conn:%s] %s not locked&#x27;, connId, key);
        }
    });

    this.commitingCount++;

    // commit is not concurrency safe for same connection.
    // but database.js guarantee that every request from same connection are in series.
    return P.try(function(){
        if(self.config.disableSlave){
            return;
        }

        // Sync data to slave
        if(keys.length === 1){
            var key = keys[0];
            var doc = self._doc(key)._getChanged();
            return self.slave.set(key, doc);
        }
        else{
            var docs = utils.forceHashMap();
            keys.forEach(function(key){
                docs[key] = self._doc(key)._getChanged();
            });
            return self.slave.setMulti(docs);
        }
        //TODO: possibly loss consistency
        //      if setMulti return failed but actually sccuess
    })
    .then(function(){
        // Real Commit
        keys.forEach(function(key){
            self._doc(key).commit(connId);
        });

        self.logger.debug(&#x27;[conn:%s] commit(%j)&#x27;, connId, keys);
    })
    .finally(function(ret){
        self.commitingCount--;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
proto.commit = function(){
var self = this;
return P.each(Object.keys(this.collections), function(name){
    var collection = self.collections[name];
    return collection.commitIndex();
})
.then(function(){
    return self.shard.<span class="apidocCodeKeywordSpan">commit</span>(self._id, Object.keys(self.lockedKeys));
})
.then(function(){
    self.lockedKeys = {};

    self.logger.debug(&#x27;[conn:%s] commited&#x27;, self._id);
    return true;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.find" id="apidoc.element.memdb-server.shard.prototype.find">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>find
        <span class="apidocSignatureSpan">(connId, key, fields)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (connId, key, fields){
    this._ensureState(STATE.RUNNING);
    var self = this;

    if(this.docs[key]){ //already loaded
        if(this.docs[key].isFree()){
            // restart idle timer if doc doesn&#x27;t locked by anyone
            this._cancelIdleTimeout(key);
            this._startIdleTimeout(key);
        }

        var ret = this.docs[key].find(connId, fields);
        self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
        return ret;
    }

    return this.keyLock.acquire(key, function(){
        return P.try(function(){
            return self._load(key);
        })
        .then(function(){
            return self.docs[key].find(connId, fields);
        })
        .then(function(ret){
            self.logger.debug(&#x27;[conn:%s] find(%s, %j) =&#x3e; %j&#x27;, connId, key, fields, ret);
            return ret;
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return this._findByIndex(indexKey, indexValue, fields, opts);
};

proto.findOne = function(query, fields, opts){
opts = opts || {};
opts.limit = 1;
return this.<span class="apidocCodeKeywordSpan">find</span>(query, fields, opts)
.then(function(docs){
    if(!Array.isArray(docs)){
        return docs;
    }
    if(docs.length === 0){
        return null;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.findReadOnly" id="apidoc.element.memdb-server.shard.prototype.findReadOnly">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>findReadOnly
        <span class="apidocSignatureSpan">(connId, key, fields)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findReadOnly = function (connId, key, fields){
    this._ensureState(STATE.RUNNING);
    var self = this;

    if(this._isLoaded(key)){
        return this.find(connId, key, fields);
    }
    return P.try(function(){
        return self.backendLocker.getHolderId(key);
    })
    .then(function(shardId){
        if(!shardId || shardId === self._id){
            return self.find(connId, key, fields);
        }
        return self.autoconn.$findReadOnly(shardId, key, fields);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

proto.findById = function(id, fields, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
if(opts &#x26;&#x26; opts.readonly){
    return self.shard.<span class="apidocCodeKeywordSpan">findReadOnly</span>(self.conn._id, self._key(id), fields);
}

return P.try(function(){
    if(opts &#x26;&#x26; opts.nolock){
        return;
    }
    return self.lock(id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.flushBackend" id="apidoc.element.memdb-server.shard.prototype.flushBackend">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>flushBackend
        <span class="apidocSignatureSpan">(connId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flushBackend = function (connId){
    this._ensureState(STATE.RUNNING);
    var self = this;

    return this.taskLock.acquire(&#x27;&#x27;, function(){
        return P.mapLimit(Object.keys(self.commitedKeys), function(key){
            return self.keyLock.acquire(key, function(){
                return self._persistent(key);
            });
        });
    })
    .then(function(){
        self.logger.warn(&#x27;[conn:%s] flushed Backend&#x27;, connId);
        return true;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.lockedKeys = {};

    this.logger.debug(&#x27;[conn:%s] rolledback&#x27;, this._id);
    return true;
};

proto.flushBackend = function(){
    return this.shard.<span class="apidocCodeKeywordSpan">flushBackend</span>(this._id);
};

// for internal use
proto.$unload = function(key){
    return this.shard.$unload(key);
};
// for internal use
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.gc" id="apidoc.element.memdb-server.shard.prototype.gc">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>gc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gc = function (){
    if(this.state !== STATE.RUNNING){
        return;
    }
    if(this.taskLock.isBusy(&#x27;&#x27;)){
        return;
    }

    var self = this;
    return this.taskLock.acquire(&#x27;&#x27;, function(){
        var usage = process.memoryUsage();
        var memSize = usage.heapUsed;

        if(memSize &#x3c; self.config.memoryLimit * 1024 * 1024){
            // Memory not reach limit, no need to gc
            return;
        }

        self.logger.warn(&#x27;Start GC. Memory usage is too high, please reduce idleTimeout. %j&#x27;, usage);

        var startTick = Date.now();

        // remove some doc
        var keys = [], count = 0;
        for(var key in self.docs){
            keys.push(key);
            count++;
            if(count &#x3e;= self.config.gcCount){
                break;
            }
        }

        return P.mapLimit(keys, function(key){
            return self.keyLock.acquire(key, function(){
                return self._unload(key);
            })
            .catch(function(e){
                self.logger.error(e.stack);
            });
        })
        .then(function(){
            self.logger.warn(&#x27;Finish GC in %s ms. %s docs have been unloaded.&#x27;, Date.now() - startTick, keys.length);
        })
        .then(function(){
            process.nextTick(self.gc.bind(self));
        });
    })
    .catch(function(e){
        self.logger.error(e.stack);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.insert" id="apidoc.element.memdb-server.shard.prototype.insert">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>insert
        <span class="apidocSignatureSpan">(connId, key, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (connId, key, doc){
    this._ensureState(STATE.RUNNING);

    var ret = this._doc(key).insert(connId, doc);
    this.logger.debug(&#x27;[conn:%s] insert(%s, %j) =&#x3e; %s&#x27;, connId, key, doc, ret);
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    doc._id = id;

    var self = this;
    return P.try(function(){
        return self.lock(id);
    })
    .then(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">insert</span>(self.conn._id, self._key(id), doc);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    })
    .thenReturn(id);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.isLocked" id="apidoc.element.memdb-server.shard.prototype.isLocked">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>isLocked
        <span class="apidocSignatureSpan">(connId, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLocked = function (connId, key){
    return this.docs[key] &#x26;&#x26; this.docs[key].isLocked(connId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.then(function(){
    return self._finishIndexTasks(id);
});
};

proto.lock = function(id){
id = this._checkId(id);
if(this.shard.<span class="apidocCodeKeywordSpan">isLocked</span>(this.conn._id, this._key(id))){
    return;
}

var self = this;
return this.shard.lock(this.conn._id, this._key(id))
.then(function(ret){
    self.emit(&#x27;lock&#x27;, id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.lock" id="apidoc.element.memdb-server.shard.prototype.lock">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>lock
        <span class="apidocSignatureSpan">(connId, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lock = function (connId, key){
    this._ensureState(STATE.RUNNING);

    if(this.isLocked(connId, key)){
        return true;
    }

    this.logger.debug(&#x27;[conn:%s] shard.lock(%s) start&#x27;, connId, key);

    var self = this;
    return this.keyLock.acquire(key, function(){
        return P.try(function(){
            return self._load(key);
        })
        .then(function(){
            return self.docs[key].lock(connId)
            .then(function(){
                self.logger.debug(&#x27;[conn:%s] shard.lock(%s) success&#x27;, connId, key);
                return true;
            }, function(e){
                throw new Error(util.format(&#x27;[conn:%s] shard.lock(%s) failed&#x27;, connId, key));
            });
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    id = utils.uuid();
}
id = this._checkId(id);
doc._id = id;

var self = this;
return P.try(function(){
    return self.<span class="apidocCodeKeywordSpan">lock</span>(id);
})
.then(function(){
    return self.shard.insert(self.conn._id, self._key(id), doc);
})
.then(function(){
    return self._finishIndexTasks(id);
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.remove" id="apidoc.element.memdb-server.shard.prototype.remove">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>remove
        <span class="apidocSignatureSpan">(connId, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (connId, key){
    this._ensureState(STATE.RUNNING);

    var ret = this._doc(key).remove(connId);
    this.logger.debug(&#x27;[conn:%s] remove(%s) =&#x3e; %s&#x27;, connId, key, ret);
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._removeById = function(id, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">remove</span>(self.conn._id, self._key(id), opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.lock = function(id){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.restoreFromSlave" id="apidoc.element.memdb-server.shard.prototype.restoreFromSlave">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>restoreFromSlave
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restoreFromSlave = function (){
    this._ensureState(STATE.STARTING);

    return P.bind(this)
    .then(function(){
        return this.slave.getAllKeys();
    })
    .then(function(keys){
        if(keys.length === 0){
            return;
        }

        this.logger.error(&#x27;Server not stopped properly, will restore data from slave&#x27;);

        return P.bind(this)
        .then(function(){
            return this.slave.getMulti(keys);
        })
        .then(function(items){
            var self = this;
            return P.mapLimit(Object.keys(items), function(key){
                return self.keyLock.acquire(key, function(){
                    self._addDoc(key, items[key]);
                    // persistent all docs to backend
                    self._setCommited(key);
                    return self._persistent(key);
                });
            });
        })
        .then(function(){
            this.logger.warn(&#x27;restored %s keys from slave&#x27;, keys.length);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .then(function(){
if(!this.config.disableSlave){
    return this.slave.start();
}
    })
    .then(function(){
if(!this.config.disableSlave){
    return this.<span class="apidocCodeKeywordSpan">restoreFromSlave</span>();
}
    })
    .then(function(){
this.gcInterval = setInterval(this.gc.bind(this), this.config.gcInterval);

this.state = STATE.RUNNING;
this.emit(&#x27;start&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.rollback" id="apidoc.element.memdb-server.shard.prototype.rollback">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>rollback
        <span class="apidocSignatureSpan">(connId, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rollback = function (connId, keys){
    // Skip state check

    if(!Array.isArray(keys)){
        keys = [keys];
    }

    var self = this;
    keys.forEach(function(key){
        self._doc(key).rollback(connId);
    });

    this.logger.debug(&#x27;[conn:%s] rollback(%j)&#x27;, connId, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
};

var proto = Connection.prototype;

proto.close = function(){
    if(this.isDirty()){
        this.<span class="apidocCodeKeywordSpan">rollback</span>();
    }
    for(var name in this.collections){
        this.collections[name].close();
    }
};

consts.collMethods.forEach(function(method){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.start" id="apidoc.element.memdb-server.shard.prototype.start">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (){
    this._ensureState(STATE.INITED);
    this.state = STATE.STARTING;

    return P.bind(this)
    .then(function(){
        return this.backendLocker.start();
    })
    .then(function(){
        return this.backend.start();
    })
    .then(function(){
        if(!this.config.disableSlave){
            return this.slave.start();
        }
    })
    .then(function(){
        if(!this.config.disableSlave){
            return this.restoreFromSlave();
        }
    })
    .then(function(){
        this.gcInterval = setInterval(this.gc.bind(this), this.config.gcInterval);

        this.state = STATE.RUNNING;
        this.emit(&#x27;start&#x27;);
        this.logger.info(&#x27;shard started&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.stop" id="apidoc.element.memdb-server.shard.prototype.stop">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (){
    this._ensureState(STATE.RUNNING);

    // This will prevent any further requests
    // All commited data will be saved, while uncommited data will be rolled back
    this.state = STATE.STOPING;

    clearInterval(this.gcInterval);

    return P.bind(this)
    .then(function(){
        // Wait for all running task finish
        return this.taskLock.acquire(&#x27;&#x27;, function(){});
    })
    .then(function(){
        this.logger.debug(&#x27;all running tasks finished&#x27;);

        // Wait for all commit process finish
        var deferred = P.defer();
        var self = this;
        var check = function(){
            if(self.commitingCount &#x3c;= 0){
                deferred.resolve();
            }
            else{
                setTimeout(check, 200);
            }
        };
        check();
        return deferred.promise;
    })
    .then(function(){
        this.logger.debug(&#x27;all commit processes finished&#x27;);
        // WARN: Make sure all connections are closed now

        var self = this;
        return P.mapLimit(Object.keys(this.docs), function(key){
            return self.keyLock.acquire(key, function(){
                return self._unload(key);
            })
            .catch(function(e){
                self.logger.error(e.stack);
            });
        });
    })
    .then(function(){
        this.logger.debug(&#x27;all docs unloaded&#x27;);

        this.loadCounter.stop();
        this.unloadCounter.stop();
        this.persistentCounter.stop();

        if(!this.config.disableSlave){
            return this.slave.stop();
        }
    })
    .then(function(){
        return this.backend.stop();
    })
    .then(function(){
        return this.backendLocker.stop();
    })
    .then(function(){
        return this.autoconn.close();
    })
    .then(function(){
        this.state = STATE.STOPED;
        this.emit(&#x27;stop&#x27;);
        this.logger.info(&#x27;shard stoped&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.logger.info(&#x27;database started&#x27;);
    });
};

proto.stop = function(force){
    var self = this;

    this.opsCounter.<span class="apidocCodeKeywordSpan">stop</span>();
    this.tpsCounter.stop();

    return P.try(function(){
// Make sure no new request come anymore

// Wait for all operations finish
return utils.waitUntil(function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.shard.prototype.update" id="apidoc.element.memdb-server.shard.prototype.update">
        function <span class="apidocSignatureSpan">memdb-server.shard.prototype.</span>update
        <span class="apidocSignatureSpan">(connId, key, doc, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (connId, key, doc, opts){
    this._ensureState(STATE.RUNNING);

    // Since lock is called before, so doc is loaded for sure
    var ret = this._doc(key).update(connId, doc, opts);

    this.logger.debug(&#x27;[conn:%s] update(%s, %j, %j) =&#x3e; %s&#x27;, connId, key, doc, opts, ret);
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto._updateById = function(id, modifier, opts){
    id = this._checkId(id);

    var self = this;
    return P.try(function(){
        return self.shard.<span class="apidocCodeKeywordSpan">update</span>(self.conn._id, self._key(id), modifier, opts);
    })
    .then(function(){
        return self._finishIndexTasks(id);
    });
};

proto.remove = function(query, opts){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.slave" id="apidoc.module.memdb-server.slave">module memdb-server.slave</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.slave.slave" id="apidoc.element.memdb-server.slave.slave">
        function <span class="apidocSignatureSpan">memdb-server.</span>slave
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slave = function (opts){
    opts = opts || {};

    this.shardId = opts.shardId;

    this.config = {
        host : opts.host || &#x27;127.0.0.1&#x27;,
        port : opts.port || 6379,
        db : opts.db || 0,
        options : opts.options || {},
    };

    this.client = null;
    this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shardId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.slave.prototype" id="apidoc.module.memdb-server.slave.prototype">module memdb-server.slave.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype._extractKey" id="apidoc.element.memdb-server.slave.prototype._extractKey">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>_extractKey
        <span class="apidocSignatureSpan">(existKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_extractKey = function (existKey){
    var words = existKey.split(&#x27;$&#x27;);
    return words.slice(2, words.length).join(&#x27;$&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return P.bind(this)
.then(function(){
    return this.client.keysAsync(this._redisKey(&#x27;*&#x27;));
})
.then(function(keys){
    var self = this;
    return keys.map(function(key){
        return self.<span class="apidocCodeKeywordSpan">_extractKey</span>(key);
    });
});
};

proto.clear = function(){
this.logger.debug(&#x27;slave clear&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype._redisKey" id="apidoc.element.memdb-server.slave.prototype._redisKey">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>_redisKey
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_redisKey = function (key){
    return &#x27;bk$&#x27; + this.shardId + &#x27;$&#x27; + key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .then(function(){
        this.logger.info(&#x27;slave stoped&#x27;);
    });
};

proto.set = function(key, doc){
    this.logger.debug(&#x27;slave set %s&#x27;, key);
    return this.client.setAsync(this.<span class="apidocCodeKeywordSpan">_redisKey</span>(key), JSON.stringify(doc));
};

proto.del = function(key){
    this.logger.debug(&#x27;slave del %s&#x27;, key);
    return this.client.delAsync(this._redisKey(key));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.clear" id="apidoc.element.memdb-server.slave.prototype.clear">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (){
    this.logger.debug(&#x27;slave clear&#x27;);

    return P.bind(this)
    .then(function(){
        return this.client.keysAsync(this._redisKey(&#x27;*&#x27;));
    })
    .then(function(keys){
        var multi = this.client.multi();
        keys.forEach(function(key){
            multi = multi.del(key);
        });
        return multi.execAsync();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.del" id="apidoc.element.memdb-server.slave.prototype.del">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>del
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">del = function (key){
    this.logger.debug(&#x27;slave del %s&#x27;, key);
    return this.client.delAsync(this._redisKey(key));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.keyLock.acquire(key, function(){
        if(!self.docs[key]){
// possibly timing issue
// or a redundant backend lock is held caused by unsuccessful unload
self.logger.warn(&#x27;this shard does not hold %s&#x27;, key);

return P.try(function(){
    return self.slave.<span class="apidocCodeKeywordSpan">del</span>(key);
})
.then(function(){
    return self._unlockBackend(key);
})
.then(function(){
    deferred.resolve(true);
}, function(e){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.getAllKeys" id="apidoc.element.memdb-server.slave.prototype.getAllKeys">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>getAllKeys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllKeys = function (){
    this.logger.debug(&#x27;slave getAllKeys&#x27;);

    return P.bind(this)
    .then(function(){
        return this.client.keysAsync(this._redisKey(&#x27;*&#x27;));
    })
    .then(function(keys){
        var self = this;
        return keys.map(function(key){
            return self._extractKey(key);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

proto.restoreFromSlave = function(){
    this._ensureState(STATE.STARTING);

    return P.bind(this)
    .then(function(){
return this.slave.<span class="apidocCodeKeywordSpan">getAllKeys</span>();
    })
    .then(function(keys){
if(keys.length === 0){
    return;
}

this.logger.error(&#x27;Server not stopped properly, will restore data from slave&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.getMulti" id="apidoc.element.memdb-server.slave.prototype.getMulti">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>getMulti
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMulti = function (keys){
    this.logger.debug(&#x27;slave getMulti&#x27;);

    var self = this;
    var multi = this.client.multi();
    keys.forEach(function(key){
        multi = multi.get(self._redisKey(key));
    });

    return multi.execAsync()
    .then(function(results){
        var docs = {};
        for(var i in keys){
            var key = keys[i];
            if(!!results[i]){
                docs[key] = JSON.parse(results[i]);
            }
        }
        return docs;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
}

this.logger.error(&#x27;Server not stopped properly, will restore data from slave&#x27;);

return P.bind(this)
.then(function(){
    return this.slave.<span class="apidocCodeKeywordSpan">getMulti</span>(keys);
})
.then(function(items){
    var self = this;
    return P.mapLimit(Object.keys(items), function(key){
        return self.keyLock.acquire(key, function(){
            self._addDoc(key, items[key]);
            // persistent all docs to backend
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.set" id="apidoc.element.memdb-server.slave.prototype.set">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>set
        <span class="apidocSignatureSpan">(key, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, doc){
    this.logger.debug(&#x27;slave set %s&#x27;, key);
    return this.client.setAsync(this._redisKey(key), JSON.stringify(doc));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            else if(opts.unique){
                throw new Error(&#x27;Duplicate value for unique key &#x27; + indexKey);
            }

            if(doc.ids.indexOf(item._id) === -1){
                doc.ids.push(item._id);
            }
            return backend.<span class="apidocCodeKeywordSpan">set</span>(indexCollName, indexValue, doc);
        });
    });
})
.then(function(){
    logger.warn(&#x27;Finish rebuild index %s %s&#x27;, collName, indexKey);
    return backend.stop();
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.setMulti" id="apidoc.element.memdb-server.slave.prototype.setMulti">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>setMulti
        <span class="apidocSignatureSpan">(docs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMulti = function (docs){
    this.logger.debug(&#x27;slave setMulti&#x27;);

    var multi = this.client.multi();
    for(var key in docs){
        var doc = docs[key];
        multi = multi.set(this._redisKey(key), JSON.stringify(doc));
    }

    return multi.execAsync();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return self.slave.set(key, doc);
    }
    else{
        var docs = utils.forceHashMap();
        keys.forEach(function(key){
            docs[key] = self._doc(key)._getChanged();
        });
        return self.slave.<span class="apidocCodeKeywordSpan">setMulti</span>(docs);
    }
    //TODO: possibly loss consistency
    //      if setMulti return failed but actually sccuess
})
.then(function(){
    // Real Commit
    keys.forEach(function(key){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.start" id="apidoc.element.memdb-server.slave.prototype.start">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>start
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">start = function (){
    return P.bind(this)
    .then(function(){
        this.client = redis.createClient(this.config.port, this.config.host, this.config.options);
        var self = this;
        this.client.on(&#x27;error&#x27;, function(err){
            self.logger.error(err.stack);
        });
        return this.client.selectAsync(this.config.db);
    })
    .then(function(){
        this.logger.info(&#x27;slave started %s:%s:%s&#x27;, this.config.host, this.config.port, this.config.db);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
var self = this;
return this.shard.<span class="apidocCodeKeywordSpan">start</span>()
.then(function(){
    self.logger.info(&#x27;database started&#x27;);
});
};

proto.stop = function(force){
var self = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.slave.prototype.stop" id="apidoc.element.memdb-server.slave.prototype.stop">
        function <span class="apidocSignatureSpan">memdb-server.slave.prototype.</span>stop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stop = function (){
    return P.bind(this)
    .then(function(){
        return this.client.quitAsync();
    })
    .then(function(){
        this.logger.info(&#x27;slave stoped&#x27;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
self.logger.info(&#x27;database started&#x27;);
    });
};

proto.stop = function(force){
    var self = this;

    this.opsCounter.<span class="apidocCodeKeywordSpan">stop</span>();
    this.tpsCounter.stop();

    return P.try(function(){
// Make sure no new request come anymore

// Wait for all operations finish
return utils.waitUntil(function(){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.memdb-server.utils" id="apidoc.module.memdb-server.utils">module memdb-server.utils</a></h1>


    <h2>
        <a href="#apidoc.element.memdb-server.utils.clone" id="apidoc.element.memdb-server.utils.clone">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function (obj){
    return JSON.parse(JSON.stringify(obj));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.shardConfig = function(shardId){
if(!_config){
    throw new Error(&#x27;please config.init first&#x27;);
}

var conf = utils.<span class="apidocCodeKeywordSpan">clone</span>(_config);

var shardConf = conf.shards &#x26;&#x26; conf.shards[shardId];
if(!shardConf){
    throw new Error(&#x27;shard &#x27; + shardId + &#x27; not configured&#x27;);
}
// Override shard specific config
for(var key in shardConf){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.deleteObjPath" id="apidoc.element.memdb-server.utils.deleteObjPath">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>deleteObjPath
        <span class="apidocSignatureSpan">(obj, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteObjPath = function (obj, path){
    if(typeof(obj) !== &#x27;object&#x27;){
        throw new Error(&#x27;not object&#x27;);
    }
    var current = obj;
    var fields = path.split(&#x27;.&#x27;);
    var finalField = fields.pop();
    fields.forEach(function(field){
        if(!!current){
            current = current[field];
        }
    });
    if(current !== undefined){
        delete current[finalField];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.$unset = function(doc, param){
if(doc === null){
    throw new Error(&#x27;doc not exist&#x27;);
}
for(var path in param){
    if(!!param[path]){
        utils.<span class="apidocCodeKeywordSpan">deleteObjPath</span>(doc, path);
    }
}
return doc;
};

exports.$inc = function(doc, param){
if(doc === null){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.escapeField" id="apidoc.element.memdb-server.utils.escapeField">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>escapeField
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">escapeField = function (str){
    return str.replace(/\\/g, &#x27;\\\\&#x27;).replace(/\$/g, &#x27;\\u0024&#x27;).replace(/\./g, &#x27;\\u002e&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        process.domain = d;
    });
};

// &#x27;index.name.key1.key2&#x27;
proto._indexCollectionName = function(indexKey){
    var keys = JSON.parse(indexKey).map(function(key){
        return utils.<span class="apidocCodeKeywordSpan">escapeField</span>(key);
    });
    return &#x27;index.&#x27; + utils.escapeField(this.name) + &#x27;.&#x27; + keys.join(&#x27;.&#x27;);
};

proto._key = function(id){
    return this.name + &#x27;$&#x27; + id;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.extendPromise" id="apidoc.element.memdb-server.utils.extendPromise">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>extendPromise
        <span class="apidocSignatureSpan">(P)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendPromise = function (P){
    // This is designed for large array
    // The original map with concurrency option does not release memory
    P.mapLimit = function(items, fn, limit){
        if(!limit){
            limit = 1000;
        }
        var groups = [];
        var group = [];
        items.forEach(function(item){
            group.push(item);
            if(group.length &#x3e;= limit){
                groups.push(group);
                group = [];
            }
        });
        if(group.length &#x3e; 0){
            groups.push(group);
        }

        var results = [];
        var promise = P.resolve();
        groups.forEach(function(group){
            promise = promise.then(function(){
                return P.map(group, fn)
                .then(function(ret){
                    ret.forEach(function(item){
                        results.push(item);
                    });
                });
            });
        });
        return promise.thenReturn(results);
    };

    P.mapSeries = function(items, fn){
        var results = [];
        return P.each(items, function(item){
            return P.try(function(){
                return fn(item);
            })
            .then(function(ret){
                results.push(ret);
            });
        })
        .thenReturn(results);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var vm = require(&#x27;vm&#x27;);
var AsyncLock = require(&#x27;async-lock&#x27;);
var _ = require(&#x27;lodash&#x27;);

var DEFAULT_SLOWQUERY = 2000;

// Extend promise
utils.<span class="apidocCodeKeywordSpan">extendPromise</span>(P);

var Database = function(opts){
// clone since we want to modify it
opts = utils.clone(opts) || {};

this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.forceHashMap" id="apidoc.element.memdb-server.utils.forceHashMap">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>forceHashMap
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forceHashMap = function (){
    var obj = {k : 1};
    delete obj.k;
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.shard = opts.shard;
this.conn = opts.conn;
this.config = opts.config || {};
this.config.maxCollision = this.config.maxCollision || DEFAULT_MAX_COLLISION;

// {indexKey : {indexValue : {id1 : 1, id2 : -1}}}
this.changedIndexes = utils.<span class="apidocCodeKeywordSpan">forceHashMap</span>();

this.pendingIndexTasks = utils.forceHashMap(); //{id, [Promise]}

this.updateIndexEvent = &#x27;updateIndex$&#x27; + this.name + &#x27;$&#x27; + this.conn._id;
this.shard.on(this.updateIndexEvent, this.onUpdateIndex.bind(this));

this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + this.shard._id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.getObjPath" id="apidoc.element.memdb-server.utils.getObjPath">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>getObjPath
        <span class="apidocSignatureSpan">(obj, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getObjPath = function (obj, path){
    var current = obj;
    path.split(&#x27;.&#x27;).forEach(function(field){
        if(!!current){
            current = current[field];
        }
    });
    return current;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

exports.$inc = function(doc, param){
if(doc === null){
    throw new Error(&#x27;doc not exist&#x27;);
}
for(var path in param){
    var value = utils.<span class="apidocCodeKeywordSpan">getObjPath</span>(doc, path);
    var delta = param[path];
    if(value === undefined){
        value = 0;
    }
    if(typeof(value) !== &#x27;number&#x27; || typeof(delta) !== &#x27;number&#x27;){
        throw new Error(&#x27;$inc non-number&#x27;);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.hrtimer" id="apidoc.element.memdb-server.utils.hrtimer">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>hrtimer
        <span class="apidocSignatureSpan">(autoStart)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hrtimer = function (autoStart){
    var total = 0;
    var starttime = null;

    var timer = {
        start : function(){
            if(starttime){
                return;
            }
            starttime = process.hrtime();
        },
        stop : function(){
            if(!starttime){
                return;
            }
            var timedelta = process.hrtime(starttime);
            total += timedelta[0] * 1000 + timedelta[1] / 1000000;
            return total;
        },
        total : function(){
            return total; //in ms
        },
    };

    if(autoStart){
        timer.start();
    }
    return timer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if(method === &#x27;commit&#x27; || method === &#x27;rollback&#x27;){
self.tpsCounter.inc();
        }
        else{
self.opsCounter.inc();
        }

        var hrtimer = utils.<span class="apidocCodeKeywordSpan">hrtimer</span>(true);
        var conn = null;

        return P.try(function(){
conn = self.getConnection(connId);

var func = conn[method];
if(typeof(func) !== &#x27;function&#x27;){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.isDict" id="apidoc.element.memdb-server.utils.isDict">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>isDict
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDict = function (obj){
    return typeof(obj) === &#x27;object&#x27; &#x26;&#x26; obj !== null &#x26;&#x26; !Array.isArray(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var self = this;
return P.mapSeries(docs, function(doc){ //disable concurrent to avoid race condition
    return self._insertById(doc &#x26;&#x26; doc._id, doc);
});
};

proto._insertById = function(id, doc){
if(!utils.<span class="apidocCodeKeywordSpan">isDict</span>(doc)){
    throw new Error(&#x27;doc must be a dictionary&#x27;);
}

if(id === null || id === undefined){
    id = utils.uuid();
}
id = this._checkId(id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.isEmpty" id="apidoc.element.memdb-server.utils.isEmpty">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>isEmpty
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isEmpty = function (obj){
    for(var key in obj){
        return false;
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.mongoForEach" id="apidoc.element.memdb-server.utils.mongoForEach">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>mongoForEach
        <span class="apidocSignatureSpan">(itor, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mongoForEach = function (itor, func){
    var deferred = P.defer();

    var next = function(err){
        if(err){
            return deferred.reject(err);
        }
        // async iterator with .next(cb)
        itor.next(function(err, value){
            if(err){
                return deferred.reject(err);
            }
            if(value === null){
                return deferred.resolve();
            }
            P.try(function(){
                return func(value);
            })
            .nodeify(next);
        });
    };
    next();

    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .then(function(){
        return backend.drop(indexCollName);
    })
    .then(function(){
        return backend.getAll(collName);
    })
    .then(function(itor){
        return utils.<span class="apidocCodeKeywordSpan">mongoForEach</span>(itor, function(item){
var indexValue = Document.prototype._getIndexValue.call({_getChanged : function(){return item;}}, indexKey, opts);
if(!indexValue){
    return;
}

return P.try(function(){
    return backend.get(indexCollName, indexValue);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.rateCounter" id="apidoc.element.memdb-server.utils.rateCounter">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>rateCounter
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rateCounter = function (opts){
    opts = opts || {};
    var perserveSeconds = opts.perserveSeconds || 3600;
    var sampleSeconds = opts.sampleSeconds || 5;

    var counts = {};
    var cleanInterval = null;

    var getCurrentSlot = function(){
        return Math.floor(Date.now() / 1000 / sampleSeconds);
    };

    var beginSlot = getCurrentSlot();

    var counter = {
        inc : function(){
            var slotNow = getCurrentSlot();
            if(!counts.hasOwnProperty(slotNow)){
                counts[slotNow] = 0;
            }
            counts[slotNow]++;
        },

        reset : function(){
            counts = {};
            beginSlot = getCurrentSlot();
        },

        clean : function(){
            var slotNow = getCurrentSlot();
            Object.keys(counts).forEach(function(slot){
                if(slot &#x3c; slotNow - Math.floor(perserveSeconds / sampleSeconds)){
                    delete counts[slot];
                }
            });
        },

        rate : function(lastSeconds){
            var slotNow = getCurrentSlot();
            var total = 0;
            var startSlot = slotNow - Math.floor(lastSeconds / sampleSeconds);
            if(startSlot &#x3c; beginSlot){
                startSlot = beginSlot;
            }
            for(var slot = startSlot; slot &#x3c; slotNow; slot++){
                total += counts[slot] || 0;
            }
            return total / ((slotNow - startSlot) * sampleSeconds);
        },

        stop : function(){
            clearInterval(cleanInterval);
        },

        counts : function(){
            return counts;
        }
    };

    cleanInterval = setInterval(function(){
        counter.clean();
    }, sampleSeconds * 1000);

    return counter;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.logger = Logger.getLogger(&#x27;memdb&#x27;, __filename, &#x27;shard:&#x27; + opts.shardId);

this.connections = utils.forceHashMap();
this.connectionLock = new AsyncLock({Promise : P});

this.dbWrappers = utils.forceHashMap(); //{connId : dbWrapper}

this.opsCounter = utils.<span class="apidocCodeKeywordSpan">rateCounter</span>();
this.tpsCounter = utils.rateCounter();

opts.slowQuery = opts.slowQuery || DEFAULT_SLOWQUERY;

// Parse index config
opts.collections = opts.collections || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.remoteExec" id="apidoc.element.memdb-server.utils.remoteExec">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>remoteExec
        <span class="apidocSignatureSpan">(ip, cmd, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remoteExec = function (ip, cmd, opts){
    ip = ip || &#x27;127.0.0.1&#x27;;
    opts = opts || {};
    var user = opts.user || process.env.USER;
    var successCodes = opts.successCodes || [0];

    var child = null;
    // localhost with current user
    if((ip === &#x27;127.0.0.1&#x27; || ip.toLowerCase() === &#x27;localhost&#x27;) &#x26;&#x26; user === process.env.USER){
        child = child_process.spawn(&#x27;bash&#x27;, [&#x27;-c&#x27;, cmd]);
    }
    // run remote via ssh
    else{
        child = child_process.spawn(&#x27;ssh&#x27;, [&#x27;-o StrictHostKeyChecking=no&#x27;, user + &#x27;@&#x27; + ip, &#x27;bash -c \&#x27;&#x27; + cmd + &#x27;\&#x27;&#x27;]);
    }

    var deferred = P.defer();
    var stdout = &#x27;&#x27;, stderr = &#x27;&#x27;;
    child.stdout.on(&#x27;data&#x27;, function(data){
        stdout += data;
    });
    child.stderr.on(&#x27;data&#x27;, function(data){
        stderr += data;
    });
    child.on(&#x27;exit&#x27;, function(code, signal){
        if(successCodes.indexOf(code) !== -1){
            deferred.resolve(stdout);
        }
        else{
            deferred.reject(new Error(util.format(&#x27;remoteExec return code %s on %s@%s - %s\n%s&#x27;, code, user, ip, cmd, stderr)));
        }
    });
    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.setObjPath" id="apidoc.element.memdb-server.utils.setObjPath">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>setObjPath
        <span class="apidocSignatureSpan">(obj, path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setObjPath = function (obj, path, value){
    if(typeof(obj) !== &#x27;object&#x27;){
        throw new Error(&#x27;not object&#x27;);
    }
    var current = obj;
    var fields = path.split(&#x27;.&#x27;);
    var finalField = fields.pop();
    fields.forEach(function(field){
        if(!current.hasOwnProperty(field)){
            current[field] = {};
        }
        current = current[field];
        if(typeof(current) !== &#x27;object&#x27;){
            throw new Error(&#x27;field &#x27; + path + &#x27; exists and not a object&#x27;);
        }
    });
    current[finalField] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.$set = function(doc, param){
if(doc === null){
    throw new Error(&#x27;doc not exist&#x27;);
}
for(var path in param){
    verifyDoc(param[path]);
    utils.<span class="apidocCodeKeywordSpan">setObjPath</span>(doc, path, param[path]);
}
return doc;
};

exports.$unset = function(doc, param){
if(doc === null){
    throw new Error(&#x27;doc not exist&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.timeCounter" id="apidoc.element.memdb-server.utils.timeCounter">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>timeCounter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timeCounter = function (){
    var counts = {};

    return {
        add : function(name, time){
            if(!counts.hasOwnProperty(name)){
                counts[name] = [0, 0, 0]; // total, count, average
            }
            var count = counts[name];
            count[0] += time;
            count[1]++;
            count[2] = count[0] / count[1];
        },
        reset : function(){
            counts = {};
        },
        getCounts : function(){
            return counts;
        },
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this.logger.info(&#x27;parsed opts: %j&#x27;, opts);

    this.shard = new Shard(opts);

    this.config = opts;

    this.timeCounter = utils.<span class="apidocCodeKeywordSpan">timeCounter</span>();
};

util.inherits(Database, EventEmitter);

var proto = Database.prototype;

proto.start = function(){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.unescapeField" id="apidoc.element.memdb-server.utils.unescapeField">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>unescapeField
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unescapeField = function (str){
    return str.replace(/\\u002e/g, &#x27;.&#x27;).replace(/\\u0024/g, &#x27;$&#x27;).replace(/\\\\/g, &#x27;\\&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.uuid" id="apidoc.element.memdb-server.utils.uuid">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>uuid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">uuid = function (){
    return uuid.v4();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

proto._insertById = function(id, doc){
if(!utils.isDict(doc)){
    throw new Error(&#x27;doc must be a dictionary&#x27;);
}

if(id === null || id === undefined){
    id = utils.<span class="apidocCodeKeywordSpan">uuid</span>();
}
id = this._checkId(id);
doc._id = id;

var self = this;
return P.try(function(){
    return self.lock(id);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.memdb-server.utils.waitUntil" id="apidoc.element.memdb-server.utils.waitUntil">
        function <span class="apidocSignatureSpan">memdb-server.utils.</span>waitUntil
        <span class="apidocSignatureSpan">(fn, checkInterval)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waitUntil = function (fn, checkInterval){
    if(!checkInterval){
        checkInterval = 100;
    }

    var deferred = P.defer();
    var check = function(){
        if(fn()){
            deferred.resolve();
        }
        else{
            setTimeout(check, checkInterval);
        }
    };
    check();

    return deferred.promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.opsCounter.stop();
this.tpsCounter.stop();

return P.try(function(){
    // Make sure no new request come anymore

    // Wait for all operations finish
    return utils.<span class="apidocCodeKeywordSpan">waitUntil</span>(function(){
        return !self.connectionLock.isBusy();
    });
})
.then(function(){
    self.logger.debug(&#x27;all requests finished&#x27;);
    return self.shard.stop(force);
})
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
